{"ast":null,"code":"/* Copyright 2016 Yury Karpovich\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n MSG Reader\n */\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    // AMD\n    define(['./DataStream'], factory);\n  } else if (typeof exports === 'object') {\n    // Node, CommonJS-like\n    module.exports = factory(require('./DataStream'));\n  } else {\n    // Browser globals (root is window)\n    root.MSGReader = factory(root.DataStream);\n  }\n})(this, function (DataStream) {\n  // constants\n  var CONST = {\n    FILE_HEADER: uInt2int([0xD0, 0xCF, 0x11, 0xE0, 0xA1, 0xB1, 0x1A, 0xE1]),\n    MSG: {\n      UNUSED_BLOCK: -1,\n      END_OF_CHAIN: -2,\n      S_BIG_BLOCK_SIZE: 0x0200,\n      S_BIG_BLOCK_MARK: 9,\n      L_BIG_BLOCK_SIZE: 0x1000,\n      L_BIG_BLOCK_MARK: 12,\n      SMALL_BLOCK_SIZE: 0x0040,\n      BIG_BLOCK_MIN_DOC_SIZE: 0x1000,\n      HEADER: {\n        PROPERTY_START_OFFSET: 0x30,\n        BAT_START_OFFSET: 0x4c,\n        BAT_COUNT_OFFSET: 0x2C,\n        SBAT_START_OFFSET: 0x3C,\n        SBAT_COUNT_OFFSET: 0x40,\n        XBAT_START_OFFSET: 0x44,\n        XBAT_COUNT_OFFSET: 0x48\n      },\n      PROP: {\n        NO_INDEX: -1,\n        PROPERTY_SIZE: 0x0080,\n        NAME_SIZE_OFFSET: 0x40,\n        MAX_NAME_LENGTH:\n        /*NAME_SIZE_OFFSET*/\n        0x40 / 2 - 1,\n        TYPE_OFFSET: 0x42,\n        PREVIOUS_PROPERTY_OFFSET: 0x44,\n        NEXT_PROPERTY_OFFSET: 0x48,\n        CHILD_PROPERTY_OFFSET: 0x4C,\n        START_BLOCK_OFFSET: 0x74,\n        SIZE_OFFSET: 0x78,\n        TYPE_ENUM: {\n          DIRECTORY: 1,\n          DOCUMENT: 2,\n          ROOT: 5\n        }\n      },\n      FIELD: {\n        PREFIX: {\n          ATTACHMENT: '__attach_version1.0',\n          RECIPIENT: '__recip_version1.0',\n          DOCUMENT: '__substg1.'\n        },\n        // example (use fields as needed)\n        NAME_MAPPING: {\n          // email specific\n          '0037': 'subject',\n          '0c1a': 'senderName',\n          '5d02': 'senderEmail',\n          '1000': 'body',\n          '007d': 'headers',\n          // attachment specific\n          '3703': 'extension',\n          '3704': 'fileNameShort',\n          '3707': 'fileName',\n          '3712': 'pidContentId',\n          // recipient specific\n          '3001': 'name',\n          '39fe': 'email'\n        },\n        CLASS_MAPPING: {\n          ATTACHMENT_DATA: '3701'\n        },\n        TYPE_MAPPING: {\n          '001e': 'string',\n          '001f': 'unicode',\n          '0102': 'binary'\n        },\n        DIR_TYPE: {\n          INNER_MSG: '000d'\n        }\n      }\n    }\n  }; // unit utils\n\n  function arraysEqual(a, b) {\n    if (a === b) return true;\n    if (a == null || b == null) return false;\n    if (a.length != b.length) return false;\n\n    for (var i = 0; i < a.length; i++) {\n      if (a[i] !== b[i]) return false;\n    }\n\n    return true;\n  }\n\n  function uInt2int(data) {\n    var result = new Array(data.length);\n\n    for (var i = 0; i < data.length; i++) {\n      result[i] = data[i] << 24 >> 24;\n    }\n\n    return result;\n  } // MSG Reader implementation\n  // check MSG file header\n\n\n  function isMSGFile(ds) {\n    ds.seek(0);\n    return arraysEqual(CONST.FILE_HEADER, ds.readInt8Array(CONST.FILE_HEADER.length));\n  } // FAT utils\n\n\n  function getBlockOffsetAt(msgData, offset) {\n    return (offset + 1) * msgData.bigBlockSize;\n  }\n\n  function getBlockAt(ds, msgData, offset) {\n    var startOffset = getBlockOffsetAt(msgData, offset);\n    ds.seek(startOffset);\n    return ds.readInt32Array(msgData.bigBlockLength);\n  }\n\n  function getNextBlockInner(ds, msgData, offset, blockOffsetData) {\n    var currentBlock = Math.floor(offset / msgData.bigBlockLength);\n    var currentBlockIndex = offset % msgData.bigBlockLength;\n    var startBlockOffset = blockOffsetData[currentBlock];\n    return getBlockAt(ds, msgData, startBlockOffset)[currentBlockIndex];\n  }\n\n  function getNextBlock(ds, msgData, offset) {\n    return getNextBlockInner(ds, msgData, offset, msgData.batData);\n  }\n\n  function getNextBlockSmall(ds, msgData, offset) {\n    return getNextBlockInner(ds, msgData, offset, msgData.sbatData);\n  } // convert binary data to dictionary\n\n\n  function parseMsgData(ds) {\n    var msgData = headerData(ds);\n    msgData.batData = batData(ds, msgData);\n    msgData.sbatData = sbatData(ds, msgData);\n\n    if (msgData.xbatCount > 0) {\n      xbatData(ds, msgData);\n    }\n\n    msgData.propertyData = propertyData(ds, msgData);\n    msgData.fieldsData = fieldsData(ds, msgData);\n    return msgData;\n  } // extract header data\n\n\n  function headerData(ds) {\n    var headerData = {}; // system data\n\n    headerData.bigBlockSize = ds.readByte(\n    /*const position*/\n    30) == CONST.MSG.L_BIG_BLOCK_MARK ? CONST.MSG.L_BIG_BLOCK_SIZE : CONST.MSG.S_BIG_BLOCK_SIZE;\n    headerData.bigBlockLength = headerData.bigBlockSize / 4;\n    headerData.xBlockLength = headerData.bigBlockLength - 1; // header data\n\n    headerData.batCount = ds.readInt(CONST.MSG.HEADER.BAT_COUNT_OFFSET);\n    headerData.propertyStart = ds.readInt(CONST.MSG.HEADER.PROPERTY_START_OFFSET);\n    headerData.sbatStart = ds.readInt(CONST.MSG.HEADER.SBAT_START_OFFSET);\n    headerData.sbatCount = ds.readInt(CONST.MSG.HEADER.SBAT_COUNT_OFFSET);\n    headerData.xbatStart = ds.readInt(CONST.MSG.HEADER.XBAT_START_OFFSET);\n    headerData.xbatCount = ds.readInt(CONST.MSG.HEADER.XBAT_COUNT_OFFSET);\n    return headerData;\n  }\n\n  function batCountInHeader(msgData) {\n    var maxBatsInHeader = (CONST.MSG.S_BIG_BLOCK_SIZE - CONST.MSG.HEADER.BAT_START_OFFSET) / 4;\n    return Math.min(msgData.batCount, maxBatsInHeader);\n  }\n\n  function batData(ds, msgData) {\n    var result = new Array(batCountInHeader(msgData));\n    ds.seek(CONST.MSG.HEADER.BAT_START_OFFSET);\n\n    for (var i = 0; i < result.length; i++) {\n      result[i] = ds.readInt32();\n    }\n\n    return result;\n  }\n\n  function sbatData(ds, msgData) {\n    var result = [];\n    var startIndex = msgData.sbatStart;\n\n    for (var i = 0; i < msgData.sbatCount && startIndex != CONST.MSG.END_OF_CHAIN; i++) {\n      result.push(startIndex);\n      startIndex = getNextBlock(ds, msgData, startIndex);\n    }\n\n    return result;\n  }\n\n  function xbatData(ds, msgData) {\n    var batCount = batCountInHeader(msgData);\n    var batCountTotal = msgData.batCount;\n    var remainingBlocks = batCountTotal - batCount;\n    var nextBlockAt = msgData.xbatStart;\n\n    for (var i = 0; i < msgData.xbatCount; i++) {\n      var xBatBlock = getBlockAt(ds, msgData, nextBlockAt);\n      nextBlockAt = xBatBlock[msgData.xBlockLength];\n      var blocksToProcess = Math.min(remainingBlocks, msgData.xBlockLength);\n\n      for (var j = 0; j < blocksToProcess; j++) {\n        var blockStartAt = xBatBlock[j];\n\n        if (blockStartAt == CONST.MSG.UNUSED_BLOCK || blockStartAt == CONST.MSG.END_OF_CHAIN) {\n          break;\n        }\n\n        msgData.batData.push(blockStartAt);\n      }\n\n      remainingBlocks -= blocksToProcess;\n    }\n  } // extract property data and property hierarchy\n\n\n  function propertyData(ds, msgData) {\n    var props = [];\n    var currentOffset = msgData.propertyStart;\n\n    while (currentOffset != CONST.MSG.END_OF_CHAIN) {\n      convertBlockToProperties(ds, msgData, currentOffset, props);\n      currentOffset = getNextBlock(ds, msgData, currentOffset);\n    }\n\n    createPropertyHierarchy(props,\n    /*property with index 0 (zero) always as root*/\n    props[0]);\n    return props;\n  }\n\n  function convertName(ds, offset) {\n    var nameLength = ds.readShort(offset + CONST.MSG.PROP.NAME_SIZE_OFFSET);\n\n    if (nameLength < 1) {\n      return '';\n    } else {\n      return ds.readStringAt(offset, nameLength / 2);\n    }\n  }\n\n  function convertProperty(ds, index, offset) {\n    return {\n      index: index,\n      type: ds.readByte(offset + CONST.MSG.PROP.TYPE_OFFSET),\n      name: convertName(ds, offset),\n      // hierarchy\n      previousProperty: ds.readInt(offset + CONST.MSG.PROP.PREVIOUS_PROPERTY_OFFSET),\n      nextProperty: ds.readInt(offset + CONST.MSG.PROP.NEXT_PROPERTY_OFFSET),\n      childProperty: ds.readInt(offset + CONST.MSG.PROP.CHILD_PROPERTY_OFFSET),\n      // data offset\n      startBlock: ds.readInt(offset + CONST.MSG.PROP.START_BLOCK_OFFSET),\n      sizeBlock: ds.readInt(offset + CONST.MSG.PROP.SIZE_OFFSET)\n    };\n  }\n\n  function convertBlockToProperties(ds, msgData, propertyBlockOffset, props) {\n    var propertyCount = msgData.bigBlockSize / CONST.MSG.PROP.PROPERTY_SIZE;\n    var propertyOffset = getBlockOffsetAt(msgData, propertyBlockOffset);\n\n    for (var i = 0; i < propertyCount; i++) {\n      var propertyType = ds.readByte(propertyOffset + CONST.MSG.PROP.TYPE_OFFSET);\n\n      switch (propertyType) {\n        case CONST.MSG.PROP.TYPE_ENUM.ROOT:\n        case CONST.MSG.PROP.TYPE_ENUM.DIRECTORY:\n        case CONST.MSG.PROP.TYPE_ENUM.DOCUMENT:\n          props.push(convertProperty(ds, props.length, propertyOffset));\n          break;\n\n        default:\n          /* unknown property types */\n          props.push(null);\n      }\n\n      propertyOffset += CONST.MSG.PROP.PROPERTY_SIZE;\n    }\n  }\n\n  function createPropertyHierarchy(props, nodeProperty) {\n    if (nodeProperty.childProperty == CONST.MSG.PROP.NO_INDEX) {\n      return;\n    }\n\n    nodeProperty.children = [];\n    var children = [nodeProperty.childProperty];\n\n    while (children.length != 0) {\n      var currentIndex = children.shift();\n      var current = props[currentIndex];\n\n      if (current == null) {\n        continue;\n      }\n\n      nodeProperty.children.push(currentIndex);\n\n      if (current.type == CONST.MSG.PROP.TYPE_ENUM.DIRECTORY) {\n        createPropertyHierarchy(props, current);\n      }\n\n      if (current.previousProperty != CONST.MSG.PROP.NO_INDEX) {\n        children.push(current.previousProperty);\n      }\n\n      if (current.nextProperty != CONST.MSG.PROP.NO_INDEX) {\n        children.push(current.nextProperty);\n      }\n    }\n  } // extract real fields\n\n\n  function fieldsData(ds, msgData) {\n    var fields = {\n      attachments: [],\n      recipients: []\n    };\n    fieldsDataDir(ds, msgData, msgData.propertyData[0], fields);\n    return fields;\n  }\n\n  function fieldsDataDir(ds, msgData, dirProperty, fields) {\n    if (dirProperty.children && dirProperty.children.length > 0) {\n      for (var i = 0; i < dirProperty.children.length; i++) {\n        var childProperty = msgData.propertyData[dirProperty.children[i]];\n\n        if (childProperty.type == CONST.MSG.PROP.TYPE_ENUM.DIRECTORY) {\n          fieldsDataDirInner(ds, msgData, childProperty, fields);\n        } else if (childProperty.type == CONST.MSG.PROP.TYPE_ENUM.DOCUMENT && childProperty.name.indexOf(CONST.MSG.FIELD.PREFIX.DOCUMENT) == 0) {\n          fieldsDataDocument(ds, msgData, childProperty, fields);\n        }\n      }\n    }\n  }\n\n  function fieldsDataDirInner(ds, msgData, dirProperty, fields) {\n    if (dirProperty.name.indexOf(CONST.MSG.FIELD.PREFIX.ATTACHMENT) == 0) {\n      // attachment\n      var attachmentField = {};\n      fields.attachments.push(attachmentField);\n      fieldsDataDir(ds, msgData, dirProperty, attachmentField);\n    } else if (dirProperty.name.indexOf(CONST.MSG.FIELD.PREFIX.RECIPIENT) == 0) {\n      // recipient\n      var recipientField = {};\n      fields.recipients.push(recipientField);\n      fieldsDataDir(ds, msgData, dirProperty, recipientField);\n    } else {\n      // other dir\n      var childFieldType = getFieldType(dirProperty);\n\n      if (childFieldType != CONST.MSG.FIELD.DIR_TYPE.INNER_MSG) {\n        fieldsDataDir(ds, msgData, dirProperty, fields);\n      } else {\n        // MSG as attachment currently isn't supported\n        fields.innerMsgContent = true;\n      }\n    }\n  }\n\n  function fieldsDataDocument(ds, msgData, documentProperty, fields) {\n    var value = documentProperty.name.substring(12).toLowerCase();\n    var fieldClass = value.substring(0, 4);\n    var fieldType = value.substring(4, 8);\n    var fieldName = CONST.MSG.FIELD.NAME_MAPPING[fieldClass];\n\n    if (fieldName) {\n      fields[fieldName] = getFieldValue(ds, msgData, documentProperty, fieldType);\n    }\n\n    if (fieldClass == CONST.MSG.FIELD.CLASS_MAPPING.ATTACHMENT_DATA) {\n      // attachment specific info\n      fields['dataId'] = documentProperty.index;\n      fields['contentLength'] = documentProperty.sizeBlock;\n    }\n  }\n\n  function getFieldType(fieldProperty) {\n    var value = fieldProperty.name.substring(12).toLowerCase();\n    return value.substring(4, 8);\n  } // extractor structure to manage bat/sbat block types and different data types\n\n\n  var extractorFieldValue = {\n    sbat: {\n      'extractor': function extractDataViaSbat(ds, msgData, fieldProperty, dataTypeExtractor) {\n        var chain = getChainByBlockSmall(ds, msgData, fieldProperty);\n\n        if (chain.length == 1) {\n          return readDataByBlockSmall(ds, msgData, fieldProperty.startBlock, fieldProperty.sizeBlock, dataTypeExtractor);\n        } else if (chain.length > 1) {\n          return readChainDataByBlockSmall(ds, msgData, fieldProperty, chain, dataTypeExtractor);\n        }\n\n        return null;\n      },\n      dataType: {\n        'string': function extractBatString(ds, msgData, blockStartOffset, bigBlockOffset, blockSize) {\n          ds.seek(blockStartOffset + bigBlockOffset);\n          return ds.readString(blockSize);\n        },\n        'unicode': function extractBatUnicode(ds, msgData, blockStartOffset, bigBlockOffset, blockSize) {\n          ds.seek(blockStartOffset + bigBlockOffset);\n          return ds.readUCS2String(blockSize / 2);\n        },\n        'binary': function extractBatBinary(ds, msgData, blockStartOffset, bigBlockOffset, blockSize) {\n          ds.seek(blockStartOffset + bigBlockOffset);\n          var toReadLength = Math.min(Math.min(msgData.bigBlockSize - bigBlockOffset, blockSize), CONST.MSG.SMALL_BLOCK_SIZE);\n          return ds.readUint8Array(toReadLength);\n        }\n      }\n    },\n    bat: {\n      'extractor': function extractDataViaBat(ds, msgData, fieldProperty, dataTypeExtractor) {\n        var offset = getBlockOffsetAt(msgData, fieldProperty.startBlock);\n        ds.seek(offset);\n        return dataTypeExtractor(ds, fieldProperty);\n      },\n      dataType: {\n        'string': function extractSbatString(ds, fieldProperty) {\n          return ds.readString(fieldProperty.sizeBlock);\n        },\n        'unicode': function extractSbatUnicode(ds, fieldProperty) {\n          return ds.readUCS2String(fieldProperty.sizeBlock / 2);\n        },\n        'binary': function extractSbatBinary(ds, fieldProperty) {\n          return ds.readUint8Array(fieldProperty.sizeBlock);\n        }\n      }\n    }\n  };\n\n  function readDataByBlockSmall(ds, msgData, startBlock, blockSize, dataTypeExtractor) {\n    var byteOffset = startBlock * CONST.MSG.SMALL_BLOCK_SIZE;\n    var bigBlockNumber = Math.floor(byteOffset / msgData.bigBlockSize);\n    var bigBlockOffset = byteOffset % msgData.bigBlockSize;\n    var rootProp = msgData.propertyData[0];\n    var nextBlock = rootProp.startBlock;\n\n    for (var i = 0; i < bigBlockNumber; i++) {\n      nextBlock = getNextBlock(ds, msgData, nextBlock);\n    }\n\n    var blockStartOffset = getBlockOffsetAt(msgData, nextBlock);\n    return dataTypeExtractor(ds, msgData, blockStartOffset, bigBlockOffset, blockSize);\n  }\n\n  function readChainDataByBlockSmall(ds, msgData, fieldProperty, chain, dataTypeExtractor) {\n    var resultData = new Int8Array(fieldProperty.sizeBlock);\n\n    for (var i = 0, idx = 0; i < chain.length; i++) {\n      var data = readDataByBlockSmall(ds, msgData, chain[i], CONST.MSG.SMALL_BLOCK_SIZE, extractorFieldValue.sbat.dataType.binary);\n\n      for (var j = 0; j < data.length; j++) {\n        resultData[idx++] = data[j];\n      }\n    }\n\n    var localDs = new DataStream(resultData, 0, DataStream.LITTLE_ENDIAN);\n    return dataTypeExtractor(localDs, msgData, 0, 0, fieldProperty.sizeBlock);\n  }\n\n  function getChainByBlockSmall(ds, msgData, fieldProperty) {\n    var blockChain = [];\n    var nextBlockSmall = fieldProperty.startBlock;\n\n    while (nextBlockSmall != CONST.MSG.END_OF_CHAIN) {\n      blockChain.push(nextBlockSmall);\n      nextBlockSmall = getNextBlockSmall(ds, msgData, nextBlockSmall);\n    }\n\n    return blockChain;\n  }\n\n  function getFieldValue(ds, msgData, fieldProperty, type) {\n    var value = null;\n    var valueExtractor = fieldProperty.sizeBlock < CONST.MSG.BIG_BLOCK_MIN_DOC_SIZE ? extractorFieldValue.sbat : extractorFieldValue.bat;\n    var dataTypeExtractor = valueExtractor.dataType[CONST.MSG.FIELD.TYPE_MAPPING[type]];\n\n    if (dataTypeExtractor) {\n      value = valueExtractor.extractor(ds, msgData, fieldProperty, dataTypeExtractor);\n    }\n\n    return value;\n  } // MSG Reader\n\n\n  var MSGReader = function (arrayBuffer) {\n    this.ds = new DataStream(arrayBuffer, 0, DataStream.LITTLE_ENDIAN);\n  };\n\n  MSGReader.prototype = {\n    /**\n     Converts bytes to fields information\n      @return {Object} The fields data for MSG file\n     */\n    getFileData: function () {\n      if (!isMSGFile(this.ds)) {\n        return {\n          error: 'Unsupported file type!'\n        };\n      }\n\n      if (this.fileData == null) {\n        this.fileData = parseMsgData(this.ds);\n      }\n\n      return this.fileData.fieldsData;\n    },\n\n    /**\n     Reads an attachment content by key/ID\n      @return {Object} The attachment for specific attachment key\n     */\n    getAttachment: function (attach) {\n      var attachData = typeof attach === 'number' ? this.fileData.fieldsData.attachments[attach] : attach;\n      var fieldProperty = this.fileData.propertyData[attachData.dataId];\n      var fieldData = getFieldValue(this.ds, this.fileData, fieldProperty, getFieldType(fieldProperty));\n      return {\n        fileName: attachData.fileName,\n        content: fieldData\n      };\n    }\n  };\n  return MSGReader;\n});","map":null,"metadata":{},"sourceType":"script"}