{"ast":null,"code":"\"use strict\";\n\nvar _this = this;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseTIFF = void 0;\nvar tiffDataView = undefined;\nvar littleEndian = undefined;\nvar fileDirectories = [];\n\nvar isLittleEndian = function isLittleEndian() {\n  // Get byte order mark.\n  var BOM = getBytes(2, 0); // Find out the endianness.\n\n  if (BOM === 0x4949) {\n    littleEndian = true;\n  } else if (BOM === 0x4d4d) {\n    littleEndian = false;\n  } else {\n    throw TypeError(\"Invalid byte order value.\");\n  }\n\n  return littleEndian;\n};\n\nvar hasTowel = function hasTowel() {\n  // Check for towel.\n  if (getBytes(2, 2) !== 42) {\n    throw RangeError(\"You forgot your towel!\");\n    return false;\n  }\n\n  return true;\n};\n\nvar getFieldTagName = function getFieldTagName(fieldTag) {\n  // See: http://www.digitizationguidelines.gov/guidelines/TIFF_Metadata_Final.pdf\n  // See: http://www.digitalpreservation.gov/formats/content/tiff_tags.shtml\n  var fieldTagNames = {\n    // TIFF Baseline\n    0x013b: \"Artist\",\n    0x0102: \"BitsPerSample\",\n    0x0109: \"CellLength\",\n    0x0108: \"CellWidth\",\n    0x0140: \"ColorMap\",\n    0x0103: \"Compression\",\n    0x8298: \"Copyright\",\n    0x0132: \"DateTime\",\n    0x0152: \"ExtraSamples\",\n    0x010a: \"FillOrder\",\n    0x0121: \"FreeByteCounts\",\n    0x0120: \"FreeOffsets\",\n    0x0123: \"GrayResponseCurve\",\n    0x0122: \"GrayResponseUnit\",\n    0x013c: \"HostComputer\",\n    0x010e: \"ImageDescription\",\n    0x0101: \"ImageLength\",\n    0x0100: \"ImageWidth\",\n    0x010f: \"Make\",\n    0x0119: \"MaxSampleValue\",\n    0x0118: \"MinSampleValue\",\n    0x0110: \"Model\",\n    0x00fe: \"NewSubfileType\",\n    0x0112: \"Orientation\",\n    0x0106: \"PhotometricInterpretation\",\n    0x011c: \"PlanarConfiguration\",\n    0x0128: \"ResolutionUnit\",\n    0x0116: \"RowsPerStrip\",\n    0x0115: \"SamplesPerPixel\",\n    0x0131: \"Software\",\n    0x0117: \"StripByteCounts\",\n    0x0111: \"StripOffsets\",\n    0x00ff: \"SubfileType\",\n    0x0107: \"Threshholding\",\n    0x011a: \"XResolution\",\n    0x011b: \"YResolution\",\n    // TIFF Extended\n    0x0146: \"BadFaxLines\",\n    0x0147: \"CleanFaxData\",\n    0x0157: \"ClipPath\",\n    0x0148: \"ConsecutiveBadFaxLines\",\n    0x01b1: \"Decode\",\n    0x01b2: \"DefaultImageColor\",\n    0x010d: \"DocumentName\",\n    0x0150: \"DotRange\",\n    0x0141: \"HalftoneHints\",\n    0x015a: \"Indexed\",\n    0x015b: \"JPEGTables\",\n    0x011d: \"PageName\",\n    0x0129: \"PageNumber\",\n    0x013d: \"Predictor\",\n    0x013f: \"PrimaryChromaticities\",\n    0x0214: \"ReferenceBlackWhite\",\n    0x0153: \"SampleFormat\",\n    0x022f: \"StripRowCounts\",\n    0x014a: \"SubIFDs\",\n    0x0124: \"T4Options\",\n    0x0125: \"T6Options\",\n    0x0145: \"TileByteCounts\",\n    0x0143: \"TileLength\",\n    0x0144: \"TileOffsets\",\n    0x0142: \"TileWidth\",\n    0x012d: \"TransferFunction\",\n    0x013e: \"WhitePoint\",\n    0x0158: \"XClipPathUnits\",\n    0x011e: \"XPosition\",\n    0x0211: \"YCbCrCoefficients\",\n    0x0213: \"YCbCrPositioning\",\n    0x0212: \"YCbCrSubSampling\",\n    0x0159: \"YClipPathUnits\",\n    0x011f: \"YPosition\",\n    // EXIF\n    0x9202: \"ApertureValue\",\n    0xa001: \"ColorSpace\",\n    0x9004: \"DateTimeDigitized\",\n    0x9003: \"DateTimeOriginal\",\n    0x8769: \"Exif IFD\",\n    0x9000: \"ExifVersion\",\n    0x829a: \"ExposureTime\",\n    0xa300: \"FileSource\",\n    0x9209: \"Flash\",\n    0xa000: \"FlashpixVersion\",\n    0x829d: \"FNumber\",\n    0xa420: \"ImageUniqueID\",\n    0x9208: \"LightSource\",\n    0x927c: \"MakerNote\",\n    0x9201: \"ShutterSpeedValue\",\n    0x9286: \"UserComment\",\n    // IPTC\n    0x83bb: \"IPTC\",\n    // ICC\n    0x8773: \"ICC Profile\",\n    // XMP\n    0x02bc: \"XMP\",\n    // GDAL\n    0xa480: \"GDAL_METADATA\",\n    0xa481: \"GDAL_NODATA\",\n    // Photoshop\n    0x8649: \"Photoshop\"\n  };\n  var fieldTagName;\n\n  if (fieldTag in fieldTagNames) {\n    fieldTagName = fieldTagNames[fieldTag];\n  } else {\n    fieldTagName = \"Tag\" + fieldTag;\n  }\n\n  return fieldTagName;\n};\n\nvar getFieldTypeName = function getFieldTypeName(fieldType) {\n  var fieldTypeNames = {\n    0x0001: \"BYTE\",\n    0x0002: \"ASCII\",\n    0x0003: \"SHORT\",\n    0x0004: \"LONG\",\n    0x0005: \"RATIONAL\",\n    0x0006: \"SBYTE\",\n    0x0007: \"UNDEFINED\",\n    0x0008: \"SSHORT\",\n    0x0009: \"SLONG\",\n    0x000a: \"SRATIONAL\",\n    0x000b: \"FLOAT\",\n    0x000c: \"DOUBLE\"\n  };\n  var fieldTypeName;\n\n  if (fieldType in fieldTypeNames) {\n    fieldTypeName = fieldTypeNames[fieldType];\n  }\n\n  return fieldTypeName;\n};\n\nvar getFieldTypeLength = function getFieldTypeLength(fieldTypeName) {\n  var fieldTypeLength;\n\n  if ([\"BYTE\", \"ASCII\", \"SBYTE\", \"UNDEFINED\"].indexOf(fieldTypeName) !== -1) {\n    fieldTypeLength = 1;\n  } else if ([\"SHORT\", \"SSHORT\"].indexOf(fieldTypeName) !== -1) {\n    fieldTypeLength = 2;\n  } else if ([\"LONG\", \"SLONG\", \"FLOAT\"].indexOf(fieldTypeName) !== -1) {\n    fieldTypeLength = 4;\n  } else if ([\"RATIONAL\", \"SRATIONAL\", \"DOUBLE\"].indexOf(fieldTypeName) !== -1) {\n    fieldTypeLength = 8;\n  }\n\n  return fieldTypeLength;\n};\n\nvar getBits = function getBits(numBits, byteOffset, bitOffset) {\n  bitOffset = bitOffset || 0;\n  var extraBytes = Math.floor(bitOffset / 8);\n  var newByteOffset = byteOffset + extraBytes;\n  var totalBits = bitOffset + numBits;\n  var shiftRight = 32 - numBits;\n\n  if (totalBits <= 0) {\n    throw RangeError(\"No bits requested\");\n  } else if (totalBits <= 8) {\n    var shiftLeft = 24 + bitOffset;\n    var rawBits = tiffDataView.getUint8(newByteOffset, littleEndian);\n  } else if (totalBits <= 16) {\n    var shiftLeft = 16 + bitOffset;\n    var rawBits = tiffDataView.getUint16(newByteOffset, littleEndian);\n  } else if (totalBits <= 32) {\n    var shiftLeft = bitOffset;\n    var rawBits = tiffDataView.getUint32(newByteOffset, littleEndian);\n  } else {\n    throw RangeError(\"Too many bits requested\");\n  }\n\n  var chunkInfo = {\n    bits: rawBits << shiftLeft >>> shiftRight,\n    byteOffset: newByteOffset + Math.floor(totalBits / 8),\n    bitOffset: totalBits % 8\n  };\n  return chunkInfo;\n};\n\nvar getBytes = function getBytes(numBytes, offset) {\n  if (numBytes <= 0) {\n    throw RangeError(\"No bytes requested\");\n  } else if (numBytes <= 1) {\n    return tiffDataView.getUint8(offset, littleEndian);\n  } else if (numBytes <= 2) {\n    return tiffDataView.getUint16(offset, littleEndian);\n  } else if (numBytes <= 3) {\n    return tiffDataView.getUint32(offset, littleEndian) >>> 8;\n  } else if (numBytes <= 4) {\n    return tiffDataView.getUint32(offset, littleEndian);\n  } else {\n    throw RangeError(\"Too many bytes requested\");\n  }\n};\n\nvar getFieldValues = function getFieldValues(fieldTagName, fieldTypeName, typeCount, valueOffset) {\n  var fieldValues = [];\n  var fieldTypeLength = getFieldTypeLength(fieldTypeName);\n  var fieldValueSize = fieldTypeLength * typeCount;\n\n  if (fieldValueSize <= 4) {\n    // The value is stored at the big end of the valueOffset.\n    if (littleEndian === false) {\n      var value = valueOffset >>> (4 - fieldTypeLength) * 8;\n    } else {\n      var value = valueOffset;\n    }\n\n    fieldValues.push(value);\n  } else {\n    for (var i = 0; i < typeCount; i++) {\n      var indexOffset = fieldTypeLength * i;\n\n      if (fieldTypeLength >= 8) {\n        if ([\"RATIONAL\", \"SRATIONAL\"].indexOf(fieldTypeName) !== -1) {\n          // Numerator\n          fieldValues.push(getBytes(4, valueOffset + indexOffset)); // Denominator\n\n          fieldValues.push(getBytes(4, valueOffset + indexOffset + 4)); //\t\t\t\t\t} else if (['DOUBLE'].indexOf(fieldTypeName) !== -1) {\n          //\t\t\t\t\t\tfieldValues.push(getBytes(4, valueOffset + indexOffset) + getBytes(4, valueOffset + indexOffset + 4));\n        } else {\n          throw TypeError(\"Can't handle this field type or size\");\n        }\n      } else {\n        fieldValues.push(getBytes(fieldTypeLength, valueOffset + indexOffset));\n      }\n    }\n  }\n\n  if (fieldTypeName === \"ASCII\") {\n    fieldValues.forEach(function (e, i, a) {\n      a[i] = String.fromCharCode(e);\n    });\n  }\n\n  return fieldValues;\n};\n\nvar clampColorSample = function clampColorSample(colorSample, bitsPerSample) {\n  var multiplier = Math.pow(2, 8 - bitsPerSample);\n  return Math.floor(colorSample * multiplier + (multiplier - 1));\n};\n\nvar makeRGBAFillValue = function makeRGBAFillValue(r, g, b, a) {\n  if (typeof a === \"undefined\") {\n    a = 1.0;\n  }\n\n  return \"rgba(\" + r + \", \" + g + \", \" + b + \", \" + a + \")\";\n};\n\nvar parseFileDirectory = function parseFileDirectory(byteOffset) {\n  var numDirEntries = getBytes(2, byteOffset);\n  var tiffFields = [];\n\n  for (var i = byteOffset + 2, entryCount = 0; entryCount < numDirEntries; i += 12, entryCount++) {\n    var fieldTag = getBytes(2, i);\n    var fieldType = getBytes(2, i + 2);\n    var typeCount = getBytes(4, i + 4);\n    var valueOffset = getBytes(4, i + 8);\n    var fieldTagName = getFieldTagName(fieldTag);\n    var fieldTypeName = getFieldTypeName(fieldType);\n    var fieldValues = getFieldValues(fieldTagName, fieldTypeName, typeCount, valueOffset);\n    tiffFields[fieldTagName] = {\n      type: fieldTypeName,\n      values: fieldValues\n    };\n  }\n\n  fileDirectories.push(tiffFields);\n  var nextIFDByteOffset = getBytes(4, i);\n\n  if (nextIFDByteOffset === 0x00000000) {\n    return fileDirectories;\n  } else {\n    return parseFileDirectory(nextIFDByteOffset);\n  }\n};\n\nexports.parseTIFF = function (tiffArrayBuffer, _canvas) {\n  var canvas = _canvas || document.createElement(\"canvas\");\n\n  if (!tiffArrayBuffer) return;\n  tiffDataView = new DataView(tiffArrayBuffer); // canvas = _canvas;\n\n  littleEndian = isLittleEndian(tiffDataView);\n  if (!hasTowel(tiffDataView, littleEndian)) return;\n  var firstIFDByteOffset = getBytes(4, 4);\n  fileDirectories = parseFileDirectory(firstIFDByteOffset);\n  var fileDirectory = fileDirectories[0];\n  var imageWidth = fileDirectory.ImageWidth.values[0];\n  var imageLength = fileDirectory.ImageLength.values[0];\n  canvas.width = imageWidth;\n  canvas.height = imageLength;\n  var strips = [];\n  var compression = fileDirectory.Compression ? fileDirectory.Compression.values[0] : 1;\n  var samplesPerPixel = fileDirectory.SamplesPerPixel.values[0];\n  var sampleProperties = [];\n  var bitsPerPixel = 0;\n  var hasBytesPerPixel = false;\n  fileDirectory.BitsPerSample.values.forEach(function (bitsPerSample, i, bitsPerSampleValues) {\n    sampleProperties[i] = {\n      bitsPerSample: bitsPerSample,\n      hasBytesPerSample: false,\n      bytesPerSample: undefined\n    };\n\n    if (bitsPerSample % 8 === 0) {\n      sampleProperties[i].hasBytesPerSample = true;\n      sampleProperties[i].bytesPerSample = bitsPerSample / 8;\n    }\n\n    bitsPerPixel += bitsPerSample;\n  }, _this);\n\n  if (bitsPerPixel % 8 === 0) {\n    hasBytesPerPixel = true;\n    var bytesPerPixel = bitsPerPixel / 8;\n  }\n\n  var stripOffsetValues = fileDirectory.StripOffsets.values;\n  var numStripOffsetValues = stripOffsetValues.length; // StripByteCounts is supposed to be required, but see if we can recover anyway.\n\n  if (fileDirectory.StripByteCounts) {\n    var stripByteCountValues = fileDirectory.StripByteCounts.values;\n  } else {\n    // Infer StripByteCounts, if possible.\n    if (numStripOffsetValues === 1) {\n      var stripByteCountValues = [Math.ceil(imageWidth * imageLength * bitsPerPixel / 8)];\n    } else {\n      throw Error(\"Cannot recover from missing StripByteCounts\");\n    }\n  } // Loop through strips and decompress as necessary.\n\n\n  for (var i = 0; i < numStripOffsetValues; i++) {\n    var stripOffset = stripOffsetValues[i];\n    strips[i] = [];\n    var stripByteCount = stripByteCountValues[i]; // Loop through pixels.\n\n    for (var byteOffset = 0, bitOffset = 0, jIncrement = 1, getHeader = true, pixel = [], numBytes = 0, sample = 0, currentSample = 0; byteOffset < stripByteCount; byteOffset += jIncrement) {\n      // Decompress strip.\n      switch (compression) {\n        // Uncompressed\n        case 1:\n          // Loop through samples (sub-pixels).\n          for (var m = 0, pixel = []; m < samplesPerPixel; m++) {\n            if (sampleProperties[m].hasBytesPerSample) {\n              // XXX: This is wrong!\n              var sampleOffset = sampleProperties[m].bytesPerSample * m;\n              pixel.push(getBytes(sampleProperties[m].bytesPerSample, stripOffset + byteOffset + sampleOffset));\n            } else {\n              var sampleInfo = getBits(sampleProperties[m].bitsPerSample, stripOffset + byteOffset, bitOffset);\n              pixel.push(sampleInfo.bits);\n              byteOffset = sampleInfo.byteOffset - stripOffset;\n              bitOffset = sampleInfo.bitOffset;\n              throw RangeError(\"Cannot handle sub-byte bits per sample\");\n            }\n          }\n\n          strips[i].push(pixel);\n\n          if (hasBytesPerPixel) {\n            jIncrement = bytesPerPixel;\n          } else {\n            jIncrement = 0;\n            throw RangeError(\"Cannot handle sub-byte bits per pixel\");\n          }\n\n          break;\n        // CITT Group 3 1-Dimensional Modified Huffman run-length encoding\n\n        case 2:\n          // XXX: Use PDF.js code?\n          break;\n        // Group 3 Fax\n\n        case 3:\n          // XXX: Use PDF.js code?\n          break;\n        // Group 4 Fax\n\n        case 4:\n          // XXX: Use PDF.js code?\n          break;\n        // LZW\n\n        case 5:\n          // XXX: Use PDF.js code?\n          break;\n        // Old-style JPEG (TIFF 6.0)\n\n        case 6:\n          // XXX: Use PDF.js code?\n          break;\n        // New-style JPEG (TIFF Specification Supplement 2)\n\n        case 7:\n          // XXX: Use PDF.js code?\n          break;\n        // PackBits\n\n        case 32773:\n          // Are we ready for a new block?\n          if (getHeader) {\n            getHeader = false;\n            var blockLength = 1;\n            var iterations = 1; // The header byte is signed.\n\n            var header = tiffDataView.getInt8(stripOffset + byteOffset, littleEndian);\n\n            if (header >= 0 && header <= 127) {\n              // Normal pixels.\n              blockLength = header + 1;\n            } else if (header >= -127 && header <= -1) {\n              // Collapsed pixels.\n              iterations = -header + 1;\n            }\n            /*if (header === -128)*/\n            else {\n              // Placeholder byte?\n              getHeader = true;\n            }\n          } else {\n            var currentByte = getBytes(1, stripOffset + byteOffset); // Duplicate bytes, if necessary.\n\n            for (var m = 0; m < iterations; m++) {\n              if (sampleProperties[sample].hasBytesPerSample) {\n                // We're reading one byte at a time, so we need to handle multi-byte samples.\n                currentSample = currentSample << 8 * numBytes | currentByte;\n                numBytes++; // Is our sample complete?\n\n                if (numBytes === sampleProperties[sample].bytesPerSample) {\n                  pixel.push(currentSample);\n                  currentSample = numBytes = 0;\n                  sample++;\n                }\n              } else {\n                throw RangeError(\"Cannot handle sub-byte bits per sample\");\n              } // Is our pixel complete?\n\n\n              if (sample === samplesPerPixel) {\n                strips[i].push(pixel);\n                pixel = [];\n                sample = 0;\n              }\n            }\n\n            blockLength--; // Is our block complete?\n\n            if (blockLength === 0) {\n              getHeader = true;\n            }\n          }\n\n          jIncrement = 1;\n          break;\n        // Unknown compression algorithm\n\n        default:\n          // Do not attempt to parse the image data.\n          break;\n      }\n    }\n  }\n\n  if (canvas.getContext) {\n    var ctx = canvas.getContext(\"2d\"); // Set a default fill style.\n\n    ctx.fillStyle = makeRGBAFillValue(255, 255, 255, 0); // If RowsPerStrip is missing, the whole image is in one strip.\n\n    if (fileDirectory.RowsPerStrip) {\n      var rowsPerStrip = fileDirectory.RowsPerStrip.values[0];\n    } else {\n      var rowsPerStrip = imageLength;\n    }\n\n    var numStrips = strips.length;\n    var imageLengthModRowsPerStrip = imageLength % rowsPerStrip;\n    var rowsInLastStrip = imageLengthModRowsPerStrip === 0 ? rowsPerStrip : imageLengthModRowsPerStrip;\n    var numRowsInStrip = rowsPerStrip;\n    var numRowsInPreviousStrip = 0;\n    var photometricInterpretation = fileDirectory.PhotometricInterpretation.values[0];\n    var extraSamplesValues = [];\n    var numExtraSamples = 0;\n\n    if (fileDirectory.ExtraSamples) {\n      extraSamplesValues = fileDirectory.ExtraSamples.values;\n      numExtraSamples = extraSamplesValues.length;\n    }\n\n    if (fileDirectory.ColorMap) {\n      var colorMapValues = fileDirectory.ColorMap.values;\n      var colorMapSampleSize = Math.pow(2, sampleProperties[0].bitsPerSample);\n    } // Loop through the strips in the image.\n\n\n    for (var i = 0; i < numStrips; i++) {\n      // The last strip may be short.\n      if (i + 1 === numStrips) {\n        numRowsInStrip = rowsInLastStrip;\n      }\n\n      var numPixels = strips[i].length;\n      var yPadding = numRowsInPreviousStrip * i; // Loop through the rows in the strip.\n\n      for (var y = 0, j = 0; y < numRowsInStrip, j < numPixels; y++) {\n        // Loop through the pixels in the row.\n        for (var x = 0; x < imageWidth; x++, j++) {\n          var pixelSamples = strips[i][j];\n          var red = 0;\n          var green = 0;\n          var blue = 0;\n          var opacity = 1.0;\n\n          if (numExtraSamples > 0) {\n            for (var k = 0; k < numExtraSamples; k++) {\n              if (extraSamplesValues[k] === 1 || extraSamplesValues[k] === 2) {\n                // Clamp opacity to the range [0,1].\n                opacity = pixelSamples[3 + k] / 256;\n                break;\n              }\n            }\n          }\n\n          switch (photometricInterpretation) {\n            // Bilevel or Grayscale\n            // WhiteIsZero\n            case 0:\n              if (sampleProperties[0].hasBytesPerSample) {\n                var invertValue = Math.pow(0x10, sampleProperties[0].bytesPerSample * 2);\n              } // Invert samples.\n\n\n              pixelSamples.forEach(function (sample, index, samples) {\n                samples[index] = invertValue - sample;\n              });\n            // Bilevel or Grayscale\n            // BlackIsZero\n\n            case 1:\n              red = green = blue = clampColorSample(pixelSamples[0], sampleProperties[0].bitsPerSample);\n              break;\n            // RGB Full Color\n\n            case 2:\n              red = clampColorSample(pixelSamples[0], sampleProperties[0].bitsPerSample);\n              green = clampColorSample(pixelSamples[1], sampleProperties[1].bitsPerSample);\n              blue = clampColorSample(pixelSamples[2], sampleProperties[2].bitsPerSample);\n              break;\n            // RGB Color Palette\n\n            case 3:\n              if (colorMapValues === undefined) {\n                throw Error(\"Palette image missing color map\");\n              }\n\n              var colorMapIndex = pixelSamples[0];\n              red = clampColorSample(colorMapValues[colorMapIndex], 16);\n              green = clampColorSample(colorMapValues[colorMapSampleSize + colorMapIndex], 16);\n              blue = clampColorSample(colorMapValues[2 * colorMapSampleSize + colorMapIndex], 16);\n              break;\n            // Transparency mask\n\n            case 4:\n              throw RangeError(\"Not Yet Implemented: Transparency mask\");\n              break;\n            // CMYK\n\n            case 5:\n              throw RangeError(\"Not Yet Implemented: CMYK\");\n              break;\n            // YCbCr\n\n            case 6:\n              throw RangeError(\"Not Yet Implemented: YCbCr\");\n              break;\n            // CIELab\n\n            case 8:\n              throw RangeError(\"Not Yet Implemented: CIELab\");\n              break;\n            // Unknown Photometric Interpretation\n\n            default:\n              throw RangeError(\"Unknown Photometric Interpretation:\", photometricInterpretation);\n              break;\n          }\n\n          ctx.fillStyle = makeRGBAFillValue(red, green, blue, opacity);\n          ctx.fillRect(x, yPadding + y, 1, 1);\n        }\n      }\n\n      numRowsInPreviousStrip = numRowsInStrip;\n    }\n  }\n\n  return canvas;\n};","map":null,"metadata":{},"sourceType":"script"}