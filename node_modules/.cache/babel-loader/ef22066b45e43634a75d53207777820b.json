{"ast":null,"code":"\"use strict\";\n\nvar _this = this;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseTIFF = void 0;\nvar tiffDataView = undefined;\nvar littleEndian = undefined;\nvar fileDirectories = [];\n\nvar isLittleEndian = function () {\n  // Get byte order mark.\n  var BOM = getBytes(2, 0); // Find out the endianness.\n\n  if (BOM === 0x4949) {\n    littleEndian = true;\n  } else if (BOM === 0x4d4d) {\n    littleEndian = false;\n  } else {\n    throw TypeError(\"Invalid byte order value.\");\n  }\n\n  return littleEndian;\n};\n\nvar hasTowel = function () {\n  // Check for towel.\n  if (getBytes(2, 2) !== 42) {\n    throw RangeError(\"You forgot your towel!\");\n    return false;\n  }\n\n  return true;\n};\n\nvar getFieldTagName = function (fieldTag) {\n  // See: http://www.digitizationguidelines.gov/guidelines/TIFF_Metadata_Final.pdf\n  // See: http://www.digitalpreservation.gov/formats/content/tiff_tags.shtml\n  var fieldTagNames = {\n    // TIFF Baseline\n    0x013b: \"Artist\",\n    0x0102: \"BitsPerSample\",\n    0x0109: \"CellLength\",\n    0x0108: \"CellWidth\",\n    0x0140: \"ColorMap\",\n    0x0103: \"Compression\",\n    0x8298: \"Copyright\",\n    0x0132: \"DateTime\",\n    0x0152: \"ExtraSamples\",\n    0x010a: \"FillOrder\",\n    0x0121: \"FreeByteCounts\",\n    0x0120: \"FreeOffsets\",\n    0x0123: \"GrayResponseCurve\",\n    0x0122: \"GrayResponseUnit\",\n    0x013c: \"HostComputer\",\n    0x010e: \"ImageDescription\",\n    0x0101: \"ImageLength\",\n    0x0100: \"ImageWidth\",\n    0x010f: \"Make\",\n    0x0119: \"MaxSampleValue\",\n    0x0118: \"MinSampleValue\",\n    0x0110: \"Model\",\n    0x00fe: \"NewSubfileType\",\n    0x0112: \"Orientation\",\n    0x0106: \"PhotometricInterpretation\",\n    0x011c: \"PlanarConfiguration\",\n    0x0128: \"ResolutionUnit\",\n    0x0116: \"RowsPerStrip\",\n    0x0115: \"SamplesPerPixel\",\n    0x0131: \"Software\",\n    0x0117: \"StripByteCounts\",\n    0x0111: \"StripOffsets\",\n    0x00ff: \"SubfileType\",\n    0x0107: \"Threshholding\",\n    0x011a: \"XResolution\",\n    0x011b: \"YResolution\",\n    // TIFF Extended\n    0x0146: \"BadFaxLines\",\n    0x0147: \"CleanFaxData\",\n    0x0157: \"ClipPath\",\n    0x0148: \"ConsecutiveBadFaxLines\",\n    0x01b1: \"Decode\",\n    0x01b2: \"DefaultImageColor\",\n    0x010d: \"DocumentName\",\n    0x0150: \"DotRange\",\n    0x0141: \"HalftoneHints\",\n    0x015a: \"Indexed\",\n    0x015b: \"JPEGTables\",\n    0x011d: \"PageName\",\n    0x0129: \"PageNumber\",\n    0x013d: \"Predictor\",\n    0x013f: \"PrimaryChromaticities\",\n    0x0214: \"ReferenceBlackWhite\",\n    0x0153: \"SampleFormat\",\n    0x022f: \"StripRowCounts\",\n    0x014a: \"SubIFDs\",\n    0x0124: \"T4Options\",\n    0x0125: \"T6Options\",\n    0x0145: \"TileByteCounts\",\n    0x0143: \"TileLength\",\n    0x0144: \"TileOffsets\",\n    0x0142: \"TileWidth\",\n    0x012d: \"TransferFunction\",\n    0x013e: \"WhitePoint\",\n    0x0158: \"XClipPathUnits\",\n    0x011e: \"XPosition\",\n    0x0211: \"YCbCrCoefficients\",\n    0x0213: \"YCbCrPositioning\",\n    0x0212: \"YCbCrSubSampling\",\n    0x0159: \"YClipPathUnits\",\n    0x011f: \"YPosition\",\n    // EXIF\n    0x9202: \"ApertureValue\",\n    0xa001: \"ColorSpace\",\n    0x9004: \"DateTimeDigitized\",\n    0x9003: \"DateTimeOriginal\",\n    0x8769: \"Exif IFD\",\n    0x9000: \"ExifVersion\",\n    0x829a: \"ExposureTime\",\n    0xa300: \"FileSource\",\n    0x9209: \"Flash\",\n    0xa000: \"FlashpixVersion\",\n    0x829d: \"FNumber\",\n    0xa420: \"ImageUniqueID\",\n    0x9208: \"LightSource\",\n    0x927c: \"MakerNote\",\n    0x9201: \"ShutterSpeedValue\",\n    0x9286: \"UserComment\",\n    // IPTC\n    0x83bb: \"IPTC\",\n    // ICC\n    0x8773: \"ICC Profile\",\n    // XMP\n    0x02bc: \"XMP\",\n    // GDAL\n    0xa480: \"GDAL_METADATA\",\n    0xa481: \"GDAL_NODATA\",\n    // Photoshop\n    0x8649: \"Photoshop\"\n  };\n  var fieldTagName;\n\n  if (fieldTag in fieldTagNames) {\n    fieldTagName = fieldTagNames[fieldTag];\n  } else {\n    fieldTagName = \"Tag\" + fieldTag;\n  }\n\n  return fieldTagName;\n};\n\nvar getFieldTypeName = function (fieldType) {\n  var fieldTypeNames = {\n    0x0001: \"BYTE\",\n    0x0002: \"ASCII\",\n    0x0003: \"SHORT\",\n    0x0004: \"LONG\",\n    0x0005: \"RATIONAL\",\n    0x0006: \"SBYTE\",\n    0x0007: \"UNDEFINED\",\n    0x0008: \"SSHORT\",\n    0x0009: \"SLONG\",\n    0x000a: \"SRATIONAL\",\n    0x000b: \"FLOAT\",\n    0x000c: \"DOUBLE\"\n  };\n  var fieldTypeName;\n\n  if (fieldType in fieldTypeNames) {\n    fieldTypeName = fieldTypeNames[fieldType];\n  }\n\n  return fieldTypeName;\n};\n\nvar getFieldTypeLength = function (fieldTypeName) {\n  var fieldTypeLength;\n\n  if ([\"BYTE\", \"ASCII\", \"SBYTE\", \"UNDEFINED\"].indexOf(fieldTypeName) !== -1) {\n    fieldTypeLength = 1;\n  } else if ([\"SHORT\", \"SSHORT\"].indexOf(fieldTypeName) !== -1) {\n    fieldTypeLength = 2;\n  } else if ([\"LONG\", \"SLONG\", \"FLOAT\"].indexOf(fieldTypeName) !== -1) {\n    fieldTypeLength = 4;\n  } else if ([\"RATIONAL\", \"SRATIONAL\", \"DOUBLE\"].indexOf(fieldTypeName) !== -1) {\n    fieldTypeLength = 8;\n  }\n\n  return fieldTypeLength;\n};\n\nvar getBits = function (numBits, byteOffset, bitOffset) {\n  bitOffset = bitOffset || 0;\n  var extraBytes = Math.floor(bitOffset / 8);\n  var newByteOffset = byteOffset + extraBytes;\n  var totalBits = bitOffset + numBits;\n  var shiftRight = 32 - numBits;\n\n  if (totalBits <= 0) {\n    throw RangeError(\"No bits requested\");\n  } else if (totalBits <= 8) {\n    var shiftLeft = 24 + bitOffset;\n    var rawBits = tiffDataView.getUint8(newByteOffset, littleEndian);\n  } else if (totalBits <= 16) {\n    var shiftLeft = 16 + bitOffset;\n    var rawBits = tiffDataView.getUint16(newByteOffset, littleEndian);\n  } else if (totalBits <= 32) {\n    var shiftLeft = bitOffset;\n    var rawBits = tiffDataView.getUint32(newByteOffset, littleEndian);\n  } else {\n    throw RangeError(\"Too many bits requested\");\n  }\n\n  var chunkInfo = {\n    bits: rawBits << shiftLeft >>> shiftRight,\n    byteOffset: newByteOffset + Math.floor(totalBits / 8),\n    bitOffset: totalBits % 8\n  };\n  return chunkInfo;\n};\n\nvar getBytes = function (numBytes, offset) {\n  if (numBytes <= 0) {\n    throw RangeError(\"No bytes requested\");\n  } else if (numBytes <= 1) {\n    return tiffDataView.getUint8(offset, littleEndian);\n  } else if (numBytes <= 2) {\n    return tiffDataView.getUint16(offset, littleEndian);\n  } else if (numBytes <= 3) {\n    return tiffDataView.getUint32(offset, littleEndian) >>> 8;\n  } else if (numBytes <= 4) {\n    return tiffDataView.getUint32(offset, littleEndian);\n  } else {\n    throw RangeError(\"Too many bytes requested\");\n  }\n};\n\nvar getFieldValues = function (fieldTagName, fieldTypeName, typeCount, valueOffset) {\n  var fieldValues = [];\n  var fieldTypeLength = getFieldTypeLength(fieldTypeName);\n  var fieldValueSize = fieldTypeLength * typeCount;\n\n  if (fieldValueSize <= 4) {\n    // The value is stored at the big end of the valueOffset.\n    if (littleEndian === false) {\n      var value = valueOffset >>> (4 - fieldTypeLength) * 8;\n    } else {\n      var value = valueOffset;\n    }\n\n    fieldValues.push(value);\n  } else {\n    for (var i = 0; i < typeCount; i++) {\n      var indexOffset = fieldTypeLength * i;\n\n      if (fieldTypeLength >= 8) {\n        if ([\"RATIONAL\", \"SRATIONAL\"].indexOf(fieldTypeName) !== -1) {\n          // Numerator\n          fieldValues.push(getBytes(4, valueOffset + indexOffset)); // Denominator\n\n          fieldValues.push(getBytes(4, valueOffset + indexOffset + 4)); //\t\t\t\t\t} else if (['DOUBLE'].indexOf(fieldTypeName) !== -1) {\n          //\t\t\t\t\t\tfieldValues.push(getBytes(4, valueOffset + indexOffset) + getBytes(4, valueOffset + indexOffset + 4));\n        } else {\n          throw TypeError(\"Can't handle this field type or size\");\n        }\n      } else {\n        fieldValues.push(getBytes(fieldTypeLength, valueOffset + indexOffset));\n      }\n    }\n  }\n\n  if (fieldTypeName === \"ASCII\") {\n    fieldValues.forEach(function (e, i, a) {\n      a[i] = String.fromCharCode(e);\n    });\n  }\n\n  return fieldValues;\n};\n\nvar clampColorSample = function (colorSample, bitsPerSample) {\n  var multiplier = Math.pow(2, 8 - bitsPerSample);\n  return Math.floor(colorSample * multiplier + (multiplier - 1));\n};\n\nvar makeRGBAFillValue = function (r, g, b, a) {\n  if (typeof a === \"undefined\") {\n    a = 1.0;\n  }\n\n  return \"rgba(\" + r + \", \" + g + \", \" + b + \", \" + a + \")\";\n};\n\nvar parseFileDirectory = function (byteOffset) {\n  var numDirEntries = getBytes(2, byteOffset);\n  var tiffFields = [];\n\n  for (var i = byteOffset + 2, entryCount = 0; entryCount < numDirEntries; i += 12, entryCount++) {\n    var fieldTag = getBytes(2, i);\n    var fieldType = getBytes(2, i + 2);\n    var typeCount = getBytes(4, i + 4);\n    var valueOffset = getBytes(4, i + 8);\n    var fieldTagName = getFieldTagName(fieldTag);\n    var fieldTypeName = getFieldTypeName(fieldType);\n    var fieldValues = getFieldValues(fieldTagName, fieldTypeName, typeCount, valueOffset);\n    tiffFields[fieldTagName] = {\n      type: fieldTypeName,\n      values: fieldValues\n    };\n  }\n\n  fileDirectories.push(tiffFields);\n  var nextIFDByteOffset = getBytes(4, i);\n\n  if (nextIFDByteOffset === 0x00000000) {\n    return fileDirectories;\n  } else {\n    return parseFileDirectory(nextIFDByteOffset);\n  }\n};\n\nexports.parseTIFF = function (tiffArrayBuffer, _canvas) {\n  var canvas = _canvas || document.createElement(\"canvas\");\n\n  if (!tiffArrayBuffer) return;\n  tiffDataView = new DataView(tiffArrayBuffer); // canvas = _canvas;\n\n  littleEndian = isLittleEndian(tiffDataView);\n  if (!hasTowel(tiffDataView, littleEndian)) return;\n  var firstIFDByteOffset = getBytes(4, 4);\n  fileDirectories = parseFileDirectory(firstIFDByteOffset);\n  var fileDirectory = fileDirectories[0];\n  var imageWidth = fileDirectory.ImageWidth.values[0];\n  var imageLength = fileDirectory.ImageLength.values[0];\n  canvas.width = imageWidth;\n  canvas.height = imageLength;\n  var strips = [];\n  var compression = fileDirectory.Compression ? fileDirectory.Compression.values[0] : 1;\n  var samplesPerPixel = fileDirectory.SamplesPerPixel.values[0];\n  var sampleProperties = [];\n  var bitsPerPixel = 0;\n  var hasBytesPerPixel = false;\n  fileDirectory.BitsPerSample.values.forEach(function (bitsPerSample, i, bitsPerSampleValues) {\n    sampleProperties[i] = {\n      bitsPerSample: bitsPerSample,\n      hasBytesPerSample: false,\n      bytesPerSample: undefined\n    };\n\n    if (bitsPerSample % 8 === 0) {\n      sampleProperties[i].hasBytesPerSample = true;\n      sampleProperties[i].bytesPerSample = bitsPerSample / 8;\n    }\n\n    bitsPerPixel += bitsPerSample;\n  }, _this);\n\n  if (bitsPerPixel % 8 === 0) {\n    hasBytesPerPixel = true;\n    var bytesPerPixel = bitsPerPixel / 8;\n  }\n\n  var stripOffsetValues = fileDirectory.StripOffsets.values;\n  var numStripOffsetValues = stripOffsetValues.length; // StripByteCounts is supposed to be required, but see if we can recover anyway.\n\n  if (fileDirectory.StripByteCounts) {\n    var stripByteCountValues = fileDirectory.StripByteCounts.values;\n  } else {\n    // Infer StripByteCounts, if possible.\n    if (numStripOffsetValues === 1) {\n      var stripByteCountValues = [Math.ceil(imageWidth * imageLength * bitsPerPixel / 8)];\n    } else {\n      throw Error(\"Cannot recover from missing StripByteCounts\");\n    }\n  } // Loop through strips and decompress as necessary.\n\n\n  for (var i = 0; i < numStripOffsetValues; i++) {\n    var stripOffset = stripOffsetValues[i];\n    strips[i] = [];\n    var stripByteCount = stripByteCountValues[i]; // Loop through pixels.\n\n    for (var byteOffset = 0, bitOffset = 0, jIncrement = 1, getHeader = true, pixel = [], numBytes = 0, sample = 0, currentSample = 0; byteOffset < stripByteCount; byteOffset += jIncrement) {\n      // Decompress strip.\n      switch (compression) {\n        // Uncompressed\n        case 1:\n          // Loop through samples (sub-pixels).\n          for (var m = 0, pixel = []; m < samplesPerPixel; m++) {\n            if (sampleProperties[m].hasBytesPerSample) {\n              // XXX: This is wrong!\n              var sampleOffset = sampleProperties[m].bytesPerSample * m;\n              pixel.push(getBytes(sampleProperties[m].bytesPerSample, stripOffset + byteOffset + sampleOffset));\n            } else {\n              var sampleInfo = getBits(sampleProperties[m].bitsPerSample, stripOffset + byteOffset, bitOffset);\n              pixel.push(sampleInfo.bits);\n              byteOffset = sampleInfo.byteOffset - stripOffset;\n              bitOffset = sampleInfo.bitOffset;\n              throw RangeError(\"Cannot handle sub-byte bits per sample\");\n            }\n          }\n\n          strips[i].push(pixel);\n\n          if (hasBytesPerPixel) {\n            jIncrement = bytesPerPixel;\n          } else {\n            jIncrement = 0;\n            throw RangeError(\"Cannot handle sub-byte bits per pixel\");\n          }\n\n          break;\n        // CITT Group 3 1-Dimensional Modified Huffman run-length encoding\n\n        case 2:\n          // XXX: Use PDF.js code?\n          break;\n        // Group 3 Fax\n\n        case 3:\n          // XXX: Use PDF.js code?\n          break;\n        // Group 4 Fax\n\n        case 4:\n          // XXX: Use PDF.js code?\n          break;\n        // LZW\n\n        case 5:\n          // XXX: Use PDF.js code?\n          break;\n        // Old-style JPEG (TIFF 6.0)\n\n        case 6:\n          // XXX: Use PDF.js code?\n          break;\n        // New-style JPEG (TIFF Specification Supplement 2)\n\n        case 7:\n          // XXX: Use PDF.js code?\n          break;\n        // PackBits\n\n        case 32773:\n          // Are we ready for a new block?\n          if (getHeader) {\n            getHeader = false;\n            var blockLength = 1;\n            var iterations = 1; // The header byte is signed.\n\n            var header = tiffDataView.getInt8(stripOffset + byteOffset, littleEndian);\n\n            if (header >= 0 && header <= 127) {\n              // Normal pixels.\n              blockLength = header + 1;\n            } else if (header >= -127 && header <= -1) {\n              // Collapsed pixels.\n              iterations = -header + 1;\n            }\n            /*if (header === -128)*/\n            else {\n              // Placeholder byte?\n              getHeader = true;\n            }\n          } else {\n            var currentByte = getBytes(1, stripOffset + byteOffset); // Duplicate bytes, if necessary.\n\n            for (var m = 0; m < iterations; m++) {\n              if (sampleProperties[sample].hasBytesPerSample) {\n                // We're reading one byte at a time, so we need to handle multi-byte samples.\n                currentSample = currentSample << 8 * numBytes | currentByte;\n                numBytes++; // Is our sample complete?\n\n                if (numBytes === sampleProperties[sample].bytesPerSample) {\n                  pixel.push(currentSample);\n                  currentSample = numBytes = 0;\n                  sample++;\n                }\n              } else {\n                throw RangeError(\"Cannot handle sub-byte bits per sample\");\n              } // Is our pixel complete?\n\n\n              if (sample === samplesPerPixel) {\n                strips[i].push(pixel);\n                pixel = [];\n                sample = 0;\n              }\n            }\n\n            blockLength--; // Is our block complete?\n\n            if (blockLength === 0) {\n              getHeader = true;\n            }\n          }\n\n          jIncrement = 1;\n          break;\n        // Unknown compression algorithm\n\n        default:\n          // Do not attempt to parse the image data.\n          break;\n      }\n    }\n  }\n\n  if (canvas.getContext) {\n    var ctx = canvas.getContext(\"2d\"); // Set a default fill style.\n\n    ctx.fillStyle = makeRGBAFillValue(255, 255, 255, 0); // If RowsPerStrip is missing, the whole image is in one strip.\n\n    if (fileDirectory.RowsPerStrip) {\n      var rowsPerStrip = fileDirectory.RowsPerStrip.values[0];\n    } else {\n      var rowsPerStrip = imageLength;\n    }\n\n    var numStrips = strips.length;\n    var imageLengthModRowsPerStrip = imageLength % rowsPerStrip;\n    var rowsInLastStrip = imageLengthModRowsPerStrip === 0 ? rowsPerStrip : imageLengthModRowsPerStrip;\n    var numRowsInStrip = rowsPerStrip;\n    var numRowsInPreviousStrip = 0;\n    var photometricInterpretation = fileDirectory.PhotometricInterpretation.values[0];\n    var extraSamplesValues = [];\n    var numExtraSamples = 0;\n\n    if (fileDirectory.ExtraSamples) {\n      extraSamplesValues = fileDirectory.ExtraSamples.values;\n      numExtraSamples = extraSamplesValues.length;\n    }\n\n    if (fileDirectory.ColorMap) {\n      var colorMapValues = fileDirectory.ColorMap.values;\n      var colorMapSampleSize = Math.pow(2, sampleProperties[0].bitsPerSample);\n    } // Loop through the strips in the image.\n\n\n    for (var i = 0; i < numStrips; i++) {\n      // The last strip may be short.\n      if (i + 1 === numStrips) {\n        numRowsInStrip = rowsInLastStrip;\n      }\n\n      var numPixels = strips[i].length;\n      var yPadding = numRowsInPreviousStrip * i; // Loop through the rows in the strip.\n\n      for (var y = 0, j = 0; y < numRowsInStrip, j < numPixels; y++) {\n        // Loop through the pixels in the row.\n        for (var x = 0; x < imageWidth; x++, j++) {\n          var pixelSamples = strips[i][j];\n          var red = 0;\n          var green = 0;\n          var blue = 0;\n          var opacity = 1.0;\n\n          if (numExtraSamples > 0) {\n            for (var k = 0; k < numExtraSamples; k++) {\n              if (extraSamplesValues[k] === 1 || extraSamplesValues[k] === 2) {\n                // Clamp opacity to the range [0,1].\n                opacity = pixelSamples[3 + k] / 256;\n                break;\n              }\n            }\n          }\n\n          switch (photometricInterpretation) {\n            // Bilevel or Grayscale\n            // WhiteIsZero\n            case 0:\n              if (sampleProperties[0].hasBytesPerSample) {\n                var invertValue = Math.pow(0x10, sampleProperties[0].bytesPerSample * 2);\n              } // Invert samples.\n\n\n              pixelSamples.forEach(function (sample, index, samples) {\n                samples[index] = invertValue - sample;\n              });\n            // Bilevel or Grayscale\n            // BlackIsZero\n\n            case 1:\n              red = green = blue = clampColorSample(pixelSamples[0], sampleProperties[0].bitsPerSample);\n              break;\n            // RGB Full Color\n\n            case 2:\n              red = clampColorSample(pixelSamples[0], sampleProperties[0].bitsPerSample);\n              green = clampColorSample(pixelSamples[1], sampleProperties[1].bitsPerSample);\n              blue = clampColorSample(pixelSamples[2], sampleProperties[2].bitsPerSample);\n              break;\n            // RGB Color Palette\n\n            case 3:\n              if (colorMapValues === undefined) {\n                throw Error(\"Palette image missing color map\");\n              }\n\n              var colorMapIndex = pixelSamples[0];\n              red = clampColorSample(colorMapValues[colorMapIndex], 16);\n              green = clampColorSample(colorMapValues[colorMapSampleSize + colorMapIndex], 16);\n              blue = clampColorSample(colorMapValues[2 * colorMapSampleSize + colorMapIndex], 16);\n              break;\n            // Transparency mask\n\n            case 4:\n              throw RangeError(\"Not Yet Implemented: Transparency mask\");\n              break;\n            // CMYK\n\n            case 5:\n              throw RangeError(\"Not Yet Implemented: CMYK\");\n              break;\n            // YCbCr\n\n            case 6:\n              throw RangeError(\"Not Yet Implemented: YCbCr\");\n              break;\n            // CIELab\n\n            case 8:\n              throw RangeError(\"Not Yet Implemented: CIELab\");\n              break;\n            // Unknown Photometric Interpretation\n\n            default:\n              throw RangeError(\"Unknown Photometric Interpretation:\", photometricInterpretation);\n              break;\n          }\n\n          ctx.fillStyle = makeRGBAFillValue(red, green, blue, opacity);\n          ctx.fillRect(x, yPadding + y, 1, 1);\n        }\n      }\n\n      numRowsInPreviousStrip = numRowsInStrip;\n    }\n  }\n\n  return canvas;\n};","map":{"version":3,"names":["_this","Object","defineProperty","exports","value","parseTIFF","tiffDataView","undefined","littleEndian","fileDirectories","isLittleEndian","BOM","getBytes","TypeError","hasTowel","RangeError","getFieldTagName","fieldTag","fieldTagNames","fieldTagName","getFieldTypeName","fieldType","fieldTypeNames","fieldTypeName","getFieldTypeLength","fieldTypeLength","indexOf","getBits","numBits","byteOffset","bitOffset","extraBytes","Math","floor","newByteOffset","totalBits","shiftRight","shiftLeft","rawBits","getUint8","getUint16","getUint32","chunkInfo","bits","numBytes","offset","getFieldValues","typeCount","valueOffset","fieldValues","fieldValueSize","push","i","indexOffset","forEach","e","a","String","fromCharCode","clampColorSample","colorSample","bitsPerSample","multiplier","pow","makeRGBAFillValue","r","g","b","parseFileDirectory","numDirEntries","tiffFields","entryCount","type","values","nextIFDByteOffset","tiffArrayBuffer","_canvas","canvas","document","createElement","DataView","firstIFDByteOffset","fileDirectory","imageWidth","ImageWidth","imageLength","ImageLength","width","height","strips","compression","Compression","samplesPerPixel","SamplesPerPixel","sampleProperties","bitsPerPixel","hasBytesPerPixel","BitsPerSample","bitsPerSampleValues","hasBytesPerSample","bytesPerSample","bytesPerPixel","stripOffsetValues","StripOffsets","numStripOffsetValues","length","StripByteCounts","stripByteCountValues","ceil","Error","stripOffset","stripByteCount","jIncrement","getHeader","pixel","sample","currentSample","m","sampleOffset","sampleInfo","blockLength","iterations","header","getInt8","currentByte","getContext","ctx","fillStyle","RowsPerStrip","rowsPerStrip","numStrips","imageLengthModRowsPerStrip","rowsInLastStrip","numRowsInStrip","numRowsInPreviousStrip","photometricInterpretation","PhotometricInterpretation","extraSamplesValues","numExtraSamples","ExtraSamples","ColorMap","colorMapValues","colorMapSampleSize","numPixels","yPadding","y","j","x","pixelSamples","red","green","blue","opacity","k","invertValue","index","samples","colorMapIndex","fillRect"],"sources":["/home/bibhu/EDRdevelopment/DevBranch/ReactCodes/node_modules/react-doc-viewer/build/plugins/tiff/tiffToCanvas.js"],"sourcesContent":["\"use strict\";\nvar _this = this;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parseTIFF = void 0;\nvar tiffDataView = undefined;\nvar littleEndian = undefined;\nvar fileDirectories = [];\nvar isLittleEndian = function () {\n    // Get byte order mark.\n    var BOM = getBytes(2, 0);\n    // Find out the endianness.\n    if (BOM === 0x4949) {\n        littleEndian = true;\n    }\n    else if (BOM === 0x4d4d) {\n        littleEndian = false;\n    }\n    else {\n        throw TypeError(\"Invalid byte order value.\");\n    }\n    return littleEndian;\n};\nvar hasTowel = function () {\n    // Check for towel.\n    if (getBytes(2, 2) !== 42) {\n        throw RangeError(\"You forgot your towel!\");\n        return false;\n    }\n    return true;\n};\nvar getFieldTagName = function (fieldTag) {\n    // See: http://www.digitizationguidelines.gov/guidelines/TIFF_Metadata_Final.pdf\n    // See: http://www.digitalpreservation.gov/formats/content/tiff_tags.shtml\n    var fieldTagNames = {\n        // TIFF Baseline\n        0x013b: \"Artist\",\n        0x0102: \"BitsPerSample\",\n        0x0109: \"CellLength\",\n        0x0108: \"CellWidth\",\n        0x0140: \"ColorMap\",\n        0x0103: \"Compression\",\n        0x8298: \"Copyright\",\n        0x0132: \"DateTime\",\n        0x0152: \"ExtraSamples\",\n        0x010a: \"FillOrder\",\n        0x0121: \"FreeByteCounts\",\n        0x0120: \"FreeOffsets\",\n        0x0123: \"GrayResponseCurve\",\n        0x0122: \"GrayResponseUnit\",\n        0x013c: \"HostComputer\",\n        0x010e: \"ImageDescription\",\n        0x0101: \"ImageLength\",\n        0x0100: \"ImageWidth\",\n        0x010f: \"Make\",\n        0x0119: \"MaxSampleValue\",\n        0x0118: \"MinSampleValue\",\n        0x0110: \"Model\",\n        0x00fe: \"NewSubfileType\",\n        0x0112: \"Orientation\",\n        0x0106: \"PhotometricInterpretation\",\n        0x011c: \"PlanarConfiguration\",\n        0x0128: \"ResolutionUnit\",\n        0x0116: \"RowsPerStrip\",\n        0x0115: \"SamplesPerPixel\",\n        0x0131: \"Software\",\n        0x0117: \"StripByteCounts\",\n        0x0111: \"StripOffsets\",\n        0x00ff: \"SubfileType\",\n        0x0107: \"Threshholding\",\n        0x011a: \"XResolution\",\n        0x011b: \"YResolution\",\n        // TIFF Extended\n        0x0146: \"BadFaxLines\",\n        0x0147: \"CleanFaxData\",\n        0x0157: \"ClipPath\",\n        0x0148: \"ConsecutiveBadFaxLines\",\n        0x01b1: \"Decode\",\n        0x01b2: \"DefaultImageColor\",\n        0x010d: \"DocumentName\",\n        0x0150: \"DotRange\",\n        0x0141: \"HalftoneHints\",\n        0x015a: \"Indexed\",\n        0x015b: \"JPEGTables\",\n        0x011d: \"PageName\",\n        0x0129: \"PageNumber\",\n        0x013d: \"Predictor\",\n        0x013f: \"PrimaryChromaticities\",\n        0x0214: \"ReferenceBlackWhite\",\n        0x0153: \"SampleFormat\",\n        0x022f: \"StripRowCounts\",\n        0x014a: \"SubIFDs\",\n        0x0124: \"T4Options\",\n        0x0125: \"T6Options\",\n        0x0145: \"TileByteCounts\",\n        0x0143: \"TileLength\",\n        0x0144: \"TileOffsets\",\n        0x0142: \"TileWidth\",\n        0x012d: \"TransferFunction\",\n        0x013e: \"WhitePoint\",\n        0x0158: \"XClipPathUnits\",\n        0x011e: \"XPosition\",\n        0x0211: \"YCbCrCoefficients\",\n        0x0213: \"YCbCrPositioning\",\n        0x0212: \"YCbCrSubSampling\",\n        0x0159: \"YClipPathUnits\",\n        0x011f: \"YPosition\",\n        // EXIF\n        0x9202: \"ApertureValue\",\n        0xa001: \"ColorSpace\",\n        0x9004: \"DateTimeDigitized\",\n        0x9003: \"DateTimeOriginal\",\n        0x8769: \"Exif IFD\",\n        0x9000: \"ExifVersion\",\n        0x829a: \"ExposureTime\",\n        0xa300: \"FileSource\",\n        0x9209: \"Flash\",\n        0xa000: \"FlashpixVersion\",\n        0x829d: \"FNumber\",\n        0xa420: \"ImageUniqueID\",\n        0x9208: \"LightSource\",\n        0x927c: \"MakerNote\",\n        0x9201: \"ShutterSpeedValue\",\n        0x9286: \"UserComment\",\n        // IPTC\n        0x83bb: \"IPTC\",\n        // ICC\n        0x8773: \"ICC Profile\",\n        // XMP\n        0x02bc: \"XMP\",\n        // GDAL\n        0xa480: \"GDAL_METADATA\",\n        0xa481: \"GDAL_NODATA\",\n        // Photoshop\n        0x8649: \"Photoshop\",\n    };\n    var fieldTagName;\n    if (fieldTag in fieldTagNames) {\n        fieldTagName = fieldTagNames[fieldTag];\n    }\n    else {\n        fieldTagName = \"Tag\" + fieldTag;\n    }\n    return fieldTagName;\n};\nvar getFieldTypeName = function (fieldType) {\n    var fieldTypeNames = {\n        0x0001: \"BYTE\",\n        0x0002: \"ASCII\",\n        0x0003: \"SHORT\",\n        0x0004: \"LONG\",\n        0x0005: \"RATIONAL\",\n        0x0006: \"SBYTE\",\n        0x0007: \"UNDEFINED\",\n        0x0008: \"SSHORT\",\n        0x0009: \"SLONG\",\n        0x000a: \"SRATIONAL\",\n        0x000b: \"FLOAT\",\n        0x000c: \"DOUBLE\",\n    };\n    var fieldTypeName;\n    if (fieldType in fieldTypeNames) {\n        fieldTypeName = fieldTypeNames[fieldType];\n    }\n    return fieldTypeName;\n};\nvar getFieldTypeLength = function (fieldTypeName) {\n    var fieldTypeLength;\n    if ([\"BYTE\", \"ASCII\", \"SBYTE\", \"UNDEFINED\"].indexOf(fieldTypeName) !== -1) {\n        fieldTypeLength = 1;\n    }\n    else if ([\"SHORT\", \"SSHORT\"].indexOf(fieldTypeName) !== -1) {\n        fieldTypeLength = 2;\n    }\n    else if ([\"LONG\", \"SLONG\", \"FLOAT\"].indexOf(fieldTypeName) !== -1) {\n        fieldTypeLength = 4;\n    }\n    else if ([\"RATIONAL\", \"SRATIONAL\", \"DOUBLE\"].indexOf(fieldTypeName) !== -1) {\n        fieldTypeLength = 8;\n    }\n    return fieldTypeLength;\n};\nvar getBits = function (numBits, byteOffset, bitOffset) {\n    bitOffset = bitOffset || 0;\n    var extraBytes = Math.floor(bitOffset / 8);\n    var newByteOffset = byteOffset + extraBytes;\n    var totalBits = bitOffset + numBits;\n    var shiftRight = 32 - numBits;\n    if (totalBits <= 0) {\n        throw RangeError(\"No bits requested\");\n    }\n    else if (totalBits <= 8) {\n        var shiftLeft = 24 + bitOffset;\n        var rawBits = tiffDataView.getUint8(newByteOffset, littleEndian);\n    }\n    else if (totalBits <= 16) {\n        var shiftLeft = 16 + bitOffset;\n        var rawBits = tiffDataView.getUint16(newByteOffset, littleEndian);\n    }\n    else if (totalBits <= 32) {\n        var shiftLeft = bitOffset;\n        var rawBits = tiffDataView.getUint32(newByteOffset, littleEndian);\n    }\n    else {\n        throw RangeError(\"Too many bits requested\");\n    }\n    var chunkInfo = {\n        bits: (rawBits << shiftLeft) >>> shiftRight,\n        byteOffset: newByteOffset + Math.floor(totalBits / 8),\n        bitOffset: totalBits % 8,\n    };\n    return chunkInfo;\n};\nvar getBytes = function (numBytes, offset) {\n    if (numBytes <= 0) {\n        throw RangeError(\"No bytes requested\");\n    }\n    else if (numBytes <= 1) {\n        return tiffDataView.getUint8(offset, littleEndian);\n    }\n    else if (numBytes <= 2) {\n        return tiffDataView.getUint16(offset, littleEndian);\n    }\n    else if (numBytes <= 3) {\n        return tiffDataView.getUint32(offset, littleEndian) >>> 8;\n    }\n    else if (numBytes <= 4) {\n        return tiffDataView.getUint32(offset, littleEndian);\n    }\n    else {\n        throw RangeError(\"Too many bytes requested\");\n    }\n};\nvar getFieldValues = function (fieldTagName, fieldTypeName, typeCount, valueOffset) {\n    var fieldValues = [];\n    var fieldTypeLength = getFieldTypeLength(fieldTypeName);\n    var fieldValueSize = fieldTypeLength * typeCount;\n    if (fieldValueSize <= 4) {\n        // The value is stored at the big end of the valueOffset.\n        if (littleEndian === false) {\n            var value = valueOffset >>> ((4 - fieldTypeLength) * 8);\n        }\n        else {\n            var value = valueOffset;\n        }\n        fieldValues.push(value);\n    }\n    else {\n        for (var i = 0; i < typeCount; i++) {\n            var indexOffset = fieldTypeLength * i;\n            if (fieldTypeLength >= 8) {\n                if ([\"RATIONAL\", \"SRATIONAL\"].indexOf(fieldTypeName) !== -1) {\n                    // Numerator\n                    fieldValues.push(getBytes(4, valueOffset + indexOffset));\n                    // Denominator\n                    fieldValues.push(getBytes(4, valueOffset + indexOffset + 4));\n                    //\t\t\t\t\t} else if (['DOUBLE'].indexOf(fieldTypeName) !== -1) {\n                    //\t\t\t\t\t\tfieldValues.push(getBytes(4, valueOffset + indexOffset) + getBytes(4, valueOffset + indexOffset + 4));\n                }\n                else {\n                    throw TypeError(\"Can't handle this field type or size\");\n                }\n            }\n            else {\n                fieldValues.push(getBytes(fieldTypeLength, valueOffset + indexOffset));\n            }\n        }\n    }\n    if (fieldTypeName === \"ASCII\") {\n        fieldValues.forEach(function (e, i, a) {\n            a[i] = String.fromCharCode(e);\n        });\n    }\n    return fieldValues;\n};\nvar clampColorSample = function (colorSample, bitsPerSample) {\n    var multiplier = Math.pow(2, 8 - bitsPerSample);\n    return Math.floor(colorSample * multiplier + (multiplier - 1));\n};\nvar makeRGBAFillValue = function (r, g, b, a) {\n    if (typeof a === \"undefined\") {\n        a = 1.0;\n    }\n    return \"rgba(\" + r + \", \" + g + \", \" + b + \", \" + a + \")\";\n};\nvar parseFileDirectory = function (byteOffset) {\n    var numDirEntries = getBytes(2, byteOffset);\n    var tiffFields = [];\n    for (var i = byteOffset + 2, entryCount = 0; entryCount < numDirEntries; i += 12, entryCount++) {\n        var fieldTag = getBytes(2, i);\n        var fieldType = getBytes(2, i + 2);\n        var typeCount = getBytes(4, i + 4);\n        var valueOffset = getBytes(4, i + 8);\n        var fieldTagName = getFieldTagName(fieldTag);\n        var fieldTypeName = getFieldTypeName(fieldType);\n        var fieldValues = getFieldValues(fieldTagName, fieldTypeName, typeCount, valueOffset);\n        tiffFields[fieldTagName] = { type: fieldTypeName, values: fieldValues };\n    }\n    fileDirectories.push(tiffFields);\n    var nextIFDByteOffset = getBytes(4, i);\n    if (nextIFDByteOffset === 0x00000000) {\n        return fileDirectories;\n    }\n    else {\n        return parseFileDirectory(nextIFDByteOffset);\n    }\n};\nexports.parseTIFF = function (tiffArrayBuffer, _canvas) {\n    var canvas = _canvas || document.createElement(\"canvas\");\n    if (!tiffArrayBuffer)\n        return;\n    tiffDataView = new DataView(tiffArrayBuffer);\n    // canvas = _canvas;\n    littleEndian = isLittleEndian(tiffDataView);\n    if (!hasTowel(tiffDataView, littleEndian))\n        return;\n    var firstIFDByteOffset = getBytes(4, 4);\n    fileDirectories = parseFileDirectory(firstIFDByteOffset);\n    var fileDirectory = fileDirectories[0];\n    var imageWidth = fileDirectory.ImageWidth.values[0];\n    var imageLength = fileDirectory.ImageLength.values[0];\n    canvas.width = imageWidth;\n    canvas.height = imageLength;\n    var strips = [];\n    var compression = fileDirectory.Compression\n        ? fileDirectory.Compression.values[0]\n        : 1;\n    var samplesPerPixel = fileDirectory.SamplesPerPixel.values[0];\n    var sampleProperties = [];\n    var bitsPerPixel = 0;\n    var hasBytesPerPixel = false;\n    fileDirectory.BitsPerSample.values.forEach(function (bitsPerSample, i, bitsPerSampleValues) {\n        sampleProperties[i] = {\n            bitsPerSample: bitsPerSample,\n            hasBytesPerSample: false,\n            bytesPerSample: undefined,\n        };\n        if (bitsPerSample % 8 === 0) {\n            sampleProperties[i].hasBytesPerSample = true;\n            sampleProperties[i].bytesPerSample = bitsPerSample / 8;\n        }\n        bitsPerPixel += bitsPerSample;\n    }, _this);\n    if (bitsPerPixel % 8 === 0) {\n        hasBytesPerPixel = true;\n        var bytesPerPixel = bitsPerPixel / 8;\n    }\n    var stripOffsetValues = fileDirectory.StripOffsets.values;\n    var numStripOffsetValues = stripOffsetValues.length;\n    // StripByteCounts is supposed to be required, but see if we can recover anyway.\n    if (fileDirectory.StripByteCounts) {\n        var stripByteCountValues = fileDirectory.StripByteCounts.values;\n    }\n    else {\n        // Infer StripByteCounts, if possible.\n        if (numStripOffsetValues === 1) {\n            var stripByteCountValues = [\n                Math.ceil((imageWidth * imageLength * bitsPerPixel) / 8),\n            ];\n        }\n        else {\n            throw Error(\"Cannot recover from missing StripByteCounts\");\n        }\n    }\n    // Loop through strips and decompress as necessary.\n    for (var i = 0; i < numStripOffsetValues; i++) {\n        var stripOffset = stripOffsetValues[i];\n        strips[i] = [];\n        var stripByteCount = stripByteCountValues[i];\n        // Loop through pixels.\n        for (var byteOffset = 0, bitOffset = 0, jIncrement = 1, getHeader = true, pixel = [], numBytes = 0, sample = 0, currentSample = 0; byteOffset < stripByteCount; byteOffset += jIncrement) {\n            // Decompress strip.\n            switch (compression) {\n                // Uncompressed\n                case 1:\n                    // Loop through samples (sub-pixels).\n                    for (var m = 0, pixel = []; m < samplesPerPixel; m++) {\n                        if (sampleProperties[m].hasBytesPerSample) {\n                            // XXX: This is wrong!\n                            var sampleOffset = sampleProperties[m].bytesPerSample * m;\n                            pixel.push(getBytes(sampleProperties[m].bytesPerSample, stripOffset + byteOffset + sampleOffset));\n                        }\n                        else {\n                            var sampleInfo = getBits(sampleProperties[m].bitsPerSample, stripOffset + byteOffset, bitOffset);\n                            pixel.push(sampleInfo.bits);\n                            byteOffset = sampleInfo.byteOffset - stripOffset;\n                            bitOffset = sampleInfo.bitOffset;\n                            throw RangeError(\"Cannot handle sub-byte bits per sample\");\n                        }\n                    }\n                    strips[i].push(pixel);\n                    if (hasBytesPerPixel) {\n                        jIncrement = bytesPerPixel;\n                    }\n                    else {\n                        jIncrement = 0;\n                        throw RangeError(\"Cannot handle sub-byte bits per pixel\");\n                    }\n                    break;\n                // CITT Group 3 1-Dimensional Modified Huffman run-length encoding\n                case 2:\n                    // XXX: Use PDF.js code?\n                    break;\n                // Group 3 Fax\n                case 3:\n                    // XXX: Use PDF.js code?\n                    break;\n                // Group 4 Fax\n                case 4:\n                    // XXX: Use PDF.js code?\n                    break;\n                // LZW\n                case 5:\n                    // XXX: Use PDF.js code?\n                    break;\n                // Old-style JPEG (TIFF 6.0)\n                case 6:\n                    // XXX: Use PDF.js code?\n                    break;\n                // New-style JPEG (TIFF Specification Supplement 2)\n                case 7:\n                    // XXX: Use PDF.js code?\n                    break;\n                // PackBits\n                case 32773:\n                    // Are we ready for a new block?\n                    if (getHeader) {\n                        getHeader = false;\n                        var blockLength = 1;\n                        var iterations = 1;\n                        // The header byte is signed.\n                        var header = tiffDataView.getInt8(stripOffset + byteOffset, littleEndian);\n                        if (header >= 0 && header <= 127) {\n                            // Normal pixels.\n                            blockLength = header + 1;\n                        }\n                        else if (header >= -127 && header <= -1) {\n                            // Collapsed pixels.\n                            iterations = -header + 1;\n                        } /*if (header === -128)*/\n                        else {\n                            // Placeholder byte?\n                            getHeader = true;\n                        }\n                    }\n                    else {\n                        var currentByte = getBytes(1, stripOffset + byteOffset);\n                        // Duplicate bytes, if necessary.\n                        for (var m = 0; m < iterations; m++) {\n                            if (sampleProperties[sample].hasBytesPerSample) {\n                                // We're reading one byte at a time, so we need to handle multi-byte samples.\n                                currentSample = (currentSample << (8 * numBytes)) | currentByte;\n                                numBytes++;\n                                // Is our sample complete?\n                                if (numBytes === sampleProperties[sample].bytesPerSample) {\n                                    pixel.push(currentSample);\n                                    currentSample = numBytes = 0;\n                                    sample++;\n                                }\n                            }\n                            else {\n                                throw RangeError(\"Cannot handle sub-byte bits per sample\");\n                            }\n                            // Is our pixel complete?\n                            if (sample === samplesPerPixel) {\n                                strips[i].push(pixel);\n                                pixel = [];\n                                sample = 0;\n                            }\n                        }\n                        blockLength--;\n                        // Is our block complete?\n                        if (blockLength === 0) {\n                            getHeader = true;\n                        }\n                    }\n                    jIncrement = 1;\n                    break;\n                // Unknown compression algorithm\n                default:\n                    // Do not attempt to parse the image data.\n                    break;\n            }\n        }\n    }\n    if (canvas.getContext) {\n        var ctx = canvas.getContext(\"2d\");\n        // Set a default fill style.\n        ctx.fillStyle = makeRGBAFillValue(255, 255, 255, 0);\n        // If RowsPerStrip is missing, the whole image is in one strip.\n        if (fileDirectory.RowsPerStrip) {\n            var rowsPerStrip = fileDirectory.RowsPerStrip.values[0];\n        }\n        else {\n            var rowsPerStrip = imageLength;\n        }\n        var numStrips = strips.length;\n        var imageLengthModRowsPerStrip = imageLength % rowsPerStrip;\n        var rowsInLastStrip = imageLengthModRowsPerStrip === 0\n            ? rowsPerStrip\n            : imageLengthModRowsPerStrip;\n        var numRowsInStrip = rowsPerStrip;\n        var numRowsInPreviousStrip = 0;\n        var photometricInterpretation = fileDirectory.PhotometricInterpretation.values[0];\n        var extraSamplesValues = [];\n        var numExtraSamples = 0;\n        if (fileDirectory.ExtraSamples) {\n            extraSamplesValues = fileDirectory.ExtraSamples.values;\n            numExtraSamples = extraSamplesValues.length;\n        }\n        if (fileDirectory.ColorMap) {\n            var colorMapValues = fileDirectory.ColorMap.values;\n            var colorMapSampleSize = Math.pow(2, sampleProperties[0].bitsPerSample);\n        }\n        // Loop through the strips in the image.\n        for (var i = 0; i < numStrips; i++) {\n            // The last strip may be short.\n            if (i + 1 === numStrips) {\n                numRowsInStrip = rowsInLastStrip;\n            }\n            var numPixels = strips[i].length;\n            var yPadding = numRowsInPreviousStrip * i;\n            // Loop through the rows in the strip.\n            for (var y = 0, j = 0; y < numRowsInStrip, j < numPixels; y++) {\n                // Loop through the pixels in the row.\n                for (var x = 0; x < imageWidth; x++, j++) {\n                    var pixelSamples = strips[i][j];\n                    var red = 0;\n                    var green = 0;\n                    var blue = 0;\n                    var opacity = 1.0;\n                    if (numExtraSamples > 0) {\n                        for (var k = 0; k < numExtraSamples; k++) {\n                            if (extraSamplesValues[k] === 1 || extraSamplesValues[k] === 2) {\n                                // Clamp opacity to the range [0,1].\n                                opacity = pixelSamples[3 + k] / 256;\n                                break;\n                            }\n                        }\n                    }\n                    switch (photometricInterpretation) {\n                        // Bilevel or Grayscale\n                        // WhiteIsZero\n                        case 0:\n                            if (sampleProperties[0].hasBytesPerSample) {\n                                var invertValue = Math.pow(0x10, sampleProperties[0].bytesPerSample * 2);\n                            }\n                            // Invert samples.\n                            pixelSamples.forEach(function (sample, index, samples) {\n                                samples[index] = invertValue - sample;\n                            });\n                        // Bilevel or Grayscale\n                        // BlackIsZero\n                        case 1:\n                            red = green = blue = clampColorSample(pixelSamples[0], sampleProperties[0].bitsPerSample);\n                            break;\n                        // RGB Full Color\n                        case 2:\n                            red = clampColorSample(pixelSamples[0], sampleProperties[0].bitsPerSample);\n                            green = clampColorSample(pixelSamples[1], sampleProperties[1].bitsPerSample);\n                            blue = clampColorSample(pixelSamples[2], sampleProperties[2].bitsPerSample);\n                            break;\n                        // RGB Color Palette\n                        case 3:\n                            if (colorMapValues === undefined) {\n                                throw Error(\"Palette image missing color map\");\n                            }\n                            var colorMapIndex = pixelSamples[0];\n                            red = clampColorSample(colorMapValues[colorMapIndex], 16);\n                            green = clampColorSample(colorMapValues[colorMapSampleSize + colorMapIndex], 16);\n                            blue = clampColorSample(colorMapValues[2 * colorMapSampleSize + colorMapIndex], 16);\n                            break;\n                        // Transparency mask\n                        case 4:\n                            throw RangeError(\"Not Yet Implemented: Transparency mask\");\n                            break;\n                        // CMYK\n                        case 5:\n                            throw RangeError(\"Not Yet Implemented: CMYK\");\n                            break;\n                        // YCbCr\n                        case 6:\n                            throw RangeError(\"Not Yet Implemented: YCbCr\");\n                            break;\n                        // CIELab\n                        case 8:\n                            throw RangeError(\"Not Yet Implemented: CIELab\");\n                            break;\n                        // Unknown Photometric Interpretation\n                        default:\n                            throw RangeError(\"Unknown Photometric Interpretation:\", photometricInterpretation);\n                            break;\n                    }\n                    ctx.fillStyle = makeRGBAFillValue(red, green, blue, opacity);\n                    ctx.fillRect(x, yPadding + y, 1, 1);\n                }\n            }\n            numRowsInPreviousStrip = numRowsInStrip;\n        }\n    }\n    return canvas;\n};\n"],"mappings":"AAAA;;AACA,IAAIA,KAAK,GAAG,IAAZ;;AACAC,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;EAAEC,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,SAAR,GAAoB,KAAK,CAAzB;AACA,IAAIC,YAAY,GAAGC,SAAnB;AACA,IAAIC,YAAY,GAAGD,SAAnB;AACA,IAAIE,eAAe,GAAG,EAAtB;;AACA,IAAIC,cAAc,GAAG,YAAY;EAC7B;EACA,IAAIC,GAAG,GAAGC,QAAQ,CAAC,CAAD,EAAI,CAAJ,CAAlB,CAF6B,CAG7B;;EACA,IAAID,GAAG,KAAK,MAAZ,EAAoB;IAChBH,YAAY,GAAG,IAAf;EACH,CAFD,MAGK,IAAIG,GAAG,KAAK,MAAZ,EAAoB;IACrBH,YAAY,GAAG,KAAf;EACH,CAFI,MAGA;IACD,MAAMK,SAAS,CAAC,2BAAD,CAAf;EACH;;EACD,OAAOL,YAAP;AACH,CAdD;;AAeA,IAAIM,QAAQ,GAAG,YAAY;EACvB;EACA,IAAIF,QAAQ,CAAC,CAAD,EAAI,CAAJ,CAAR,KAAmB,EAAvB,EAA2B;IACvB,MAAMG,UAAU,CAAC,wBAAD,CAAhB;IACA,OAAO,KAAP;EACH;;EACD,OAAO,IAAP;AACH,CAPD;;AAQA,IAAIC,eAAe,GAAG,UAAUC,QAAV,EAAoB;EACtC;EACA;EACA,IAAIC,aAAa,GAAG;IAChB;IACA,QAAQ,QAFQ;IAGhB,QAAQ,eAHQ;IAIhB,QAAQ,YAJQ;IAKhB,QAAQ,WALQ;IAMhB,QAAQ,UANQ;IAOhB,QAAQ,aAPQ;IAQhB,QAAQ,WARQ;IAShB,QAAQ,UATQ;IAUhB,QAAQ,cAVQ;IAWhB,QAAQ,WAXQ;IAYhB,QAAQ,gBAZQ;IAahB,QAAQ,aAbQ;IAchB,QAAQ,mBAdQ;IAehB,QAAQ,kBAfQ;IAgBhB,QAAQ,cAhBQ;IAiBhB,QAAQ,kBAjBQ;IAkBhB,QAAQ,aAlBQ;IAmBhB,QAAQ,YAnBQ;IAoBhB,QAAQ,MApBQ;IAqBhB,QAAQ,gBArBQ;IAsBhB,QAAQ,gBAtBQ;IAuBhB,QAAQ,OAvBQ;IAwBhB,QAAQ,gBAxBQ;IAyBhB,QAAQ,aAzBQ;IA0BhB,QAAQ,2BA1BQ;IA2BhB,QAAQ,qBA3BQ;IA4BhB,QAAQ,gBA5BQ;IA6BhB,QAAQ,cA7BQ;IA8BhB,QAAQ,iBA9BQ;IA+BhB,QAAQ,UA/BQ;IAgChB,QAAQ,iBAhCQ;IAiChB,QAAQ,cAjCQ;IAkChB,QAAQ,aAlCQ;IAmChB,QAAQ,eAnCQ;IAoChB,QAAQ,aApCQ;IAqChB,QAAQ,aArCQ;IAsChB;IACA,QAAQ,aAvCQ;IAwChB,QAAQ,cAxCQ;IAyChB,QAAQ,UAzCQ;IA0ChB,QAAQ,wBA1CQ;IA2ChB,QAAQ,QA3CQ;IA4ChB,QAAQ,mBA5CQ;IA6ChB,QAAQ,cA7CQ;IA8ChB,QAAQ,UA9CQ;IA+ChB,QAAQ,eA/CQ;IAgDhB,QAAQ,SAhDQ;IAiDhB,QAAQ,YAjDQ;IAkDhB,QAAQ,UAlDQ;IAmDhB,QAAQ,YAnDQ;IAoDhB,QAAQ,WApDQ;IAqDhB,QAAQ,uBArDQ;IAsDhB,QAAQ,qBAtDQ;IAuDhB,QAAQ,cAvDQ;IAwDhB,QAAQ,gBAxDQ;IAyDhB,QAAQ,SAzDQ;IA0DhB,QAAQ,WA1DQ;IA2DhB,QAAQ,WA3DQ;IA4DhB,QAAQ,gBA5DQ;IA6DhB,QAAQ,YA7DQ;IA8DhB,QAAQ,aA9DQ;IA+DhB,QAAQ,WA/DQ;IAgEhB,QAAQ,kBAhEQ;IAiEhB,QAAQ,YAjEQ;IAkEhB,QAAQ,gBAlEQ;IAmEhB,QAAQ,WAnEQ;IAoEhB,QAAQ,mBApEQ;IAqEhB,QAAQ,kBArEQ;IAsEhB,QAAQ,kBAtEQ;IAuEhB,QAAQ,gBAvEQ;IAwEhB,QAAQ,WAxEQ;IAyEhB;IACA,QAAQ,eA1EQ;IA2EhB,QAAQ,YA3EQ;IA4EhB,QAAQ,mBA5EQ;IA6EhB,QAAQ,kBA7EQ;IA8EhB,QAAQ,UA9EQ;IA+EhB,QAAQ,aA/EQ;IAgFhB,QAAQ,cAhFQ;IAiFhB,QAAQ,YAjFQ;IAkFhB,QAAQ,OAlFQ;IAmFhB,QAAQ,iBAnFQ;IAoFhB,QAAQ,SApFQ;IAqFhB,QAAQ,eArFQ;IAsFhB,QAAQ,aAtFQ;IAuFhB,QAAQ,WAvFQ;IAwFhB,QAAQ,mBAxFQ;IAyFhB,QAAQ,aAzFQ;IA0FhB;IACA,QAAQ,MA3FQ;IA4FhB;IACA,QAAQ,aA7FQ;IA8FhB;IACA,QAAQ,KA/FQ;IAgGhB;IACA,QAAQ,eAjGQ;IAkGhB,QAAQ,aAlGQ;IAmGhB;IACA,QAAQ;EApGQ,CAApB;EAsGA,IAAIC,YAAJ;;EACA,IAAIF,QAAQ,IAAIC,aAAhB,EAA+B;IAC3BC,YAAY,GAAGD,aAAa,CAACD,QAAD,CAA5B;EACH,CAFD,MAGK;IACDE,YAAY,GAAG,QAAQF,QAAvB;EACH;;EACD,OAAOE,YAAP;AACH,CAjHD;;AAkHA,IAAIC,gBAAgB,GAAG,UAAUC,SAAV,EAAqB;EACxC,IAAIC,cAAc,GAAG;IACjB,QAAQ,MADS;IAEjB,QAAQ,OAFS;IAGjB,QAAQ,OAHS;IAIjB,QAAQ,MAJS;IAKjB,QAAQ,UALS;IAMjB,QAAQ,OANS;IAOjB,QAAQ,WAPS;IAQjB,QAAQ,QARS;IASjB,QAAQ,OATS;IAUjB,QAAQ,WAVS;IAWjB,QAAQ,OAXS;IAYjB,QAAQ;EAZS,CAArB;EAcA,IAAIC,aAAJ;;EACA,IAAIF,SAAS,IAAIC,cAAjB,EAAiC;IAC7BC,aAAa,GAAGD,cAAc,CAACD,SAAD,CAA9B;EACH;;EACD,OAAOE,aAAP;AACH,CApBD;;AAqBA,IAAIC,kBAAkB,GAAG,UAAUD,aAAV,EAAyB;EAC9C,IAAIE,eAAJ;;EACA,IAAI,CAAC,MAAD,EAAS,OAAT,EAAkB,OAAlB,EAA2B,WAA3B,EAAwCC,OAAxC,CAAgDH,aAAhD,MAAmE,CAAC,CAAxE,EAA2E;IACvEE,eAAe,GAAG,CAAlB;EACH,CAFD,MAGK,IAAI,CAAC,OAAD,EAAU,QAAV,EAAoBC,OAApB,CAA4BH,aAA5B,MAA+C,CAAC,CAApD,EAAuD;IACxDE,eAAe,GAAG,CAAlB;EACH,CAFI,MAGA,IAAI,CAAC,MAAD,EAAS,OAAT,EAAkB,OAAlB,EAA2BC,OAA3B,CAAmCH,aAAnC,MAAsD,CAAC,CAA3D,EAA8D;IAC/DE,eAAe,GAAG,CAAlB;EACH,CAFI,MAGA,IAAI,CAAC,UAAD,EAAa,WAAb,EAA0B,QAA1B,EAAoCC,OAApC,CAA4CH,aAA5C,MAA+D,CAAC,CAApE,EAAuE;IACxEE,eAAe,GAAG,CAAlB;EACH;;EACD,OAAOA,eAAP;AACH,CAfD;;AAgBA,IAAIE,OAAO,GAAG,UAAUC,OAAV,EAAmBC,UAAnB,EAA+BC,SAA/B,EAA0C;EACpDA,SAAS,GAAGA,SAAS,IAAI,CAAzB;EACA,IAAIC,UAAU,GAAGC,IAAI,CAACC,KAAL,CAAWH,SAAS,GAAG,CAAvB,CAAjB;EACA,IAAII,aAAa,GAAGL,UAAU,GAAGE,UAAjC;EACA,IAAII,SAAS,GAAGL,SAAS,GAAGF,OAA5B;EACA,IAAIQ,UAAU,GAAG,KAAKR,OAAtB;;EACA,IAAIO,SAAS,IAAI,CAAjB,EAAoB;IAChB,MAAMpB,UAAU,CAAC,mBAAD,CAAhB;EACH,CAFD,MAGK,IAAIoB,SAAS,IAAI,CAAjB,EAAoB;IACrB,IAAIE,SAAS,GAAG,KAAKP,SAArB;IACA,IAAIQ,OAAO,GAAGhC,YAAY,CAACiC,QAAb,CAAsBL,aAAtB,EAAqC1B,YAArC,CAAd;EACH,CAHI,MAIA,IAAI2B,SAAS,IAAI,EAAjB,EAAqB;IACtB,IAAIE,SAAS,GAAG,KAAKP,SAArB;IACA,IAAIQ,OAAO,GAAGhC,YAAY,CAACkC,SAAb,CAAuBN,aAAvB,EAAsC1B,YAAtC,CAAd;EACH,CAHI,MAIA,IAAI2B,SAAS,IAAI,EAAjB,EAAqB;IACtB,IAAIE,SAAS,GAAGP,SAAhB;IACA,IAAIQ,OAAO,GAAGhC,YAAY,CAACmC,SAAb,CAAuBP,aAAvB,EAAsC1B,YAAtC,CAAd;EACH,CAHI,MAIA;IACD,MAAMO,UAAU,CAAC,yBAAD,CAAhB;EACH;;EACD,IAAI2B,SAAS,GAAG;IACZC,IAAI,EAAGL,OAAO,IAAID,SAAZ,KAA2BD,UADrB;IAEZP,UAAU,EAAEK,aAAa,GAAGF,IAAI,CAACC,KAAL,CAAWE,SAAS,GAAG,CAAvB,CAFhB;IAGZL,SAAS,EAAEK,SAAS,GAAG;EAHX,CAAhB;EAKA,OAAOO,SAAP;AACH,CA9BD;;AA+BA,IAAI9B,QAAQ,GAAG,UAAUgC,QAAV,EAAoBC,MAApB,EAA4B;EACvC,IAAID,QAAQ,IAAI,CAAhB,EAAmB;IACf,MAAM7B,UAAU,CAAC,oBAAD,CAAhB;EACH,CAFD,MAGK,IAAI6B,QAAQ,IAAI,CAAhB,EAAmB;IACpB,OAAOtC,YAAY,CAACiC,QAAb,CAAsBM,MAAtB,EAA8BrC,YAA9B,CAAP;EACH,CAFI,MAGA,IAAIoC,QAAQ,IAAI,CAAhB,EAAmB;IACpB,OAAOtC,YAAY,CAACkC,SAAb,CAAuBK,MAAvB,EAA+BrC,YAA/B,CAAP;EACH,CAFI,MAGA,IAAIoC,QAAQ,IAAI,CAAhB,EAAmB;IACpB,OAAOtC,YAAY,CAACmC,SAAb,CAAuBI,MAAvB,EAA+BrC,YAA/B,MAAiD,CAAxD;EACH,CAFI,MAGA,IAAIoC,QAAQ,IAAI,CAAhB,EAAmB;IACpB,OAAOtC,YAAY,CAACmC,SAAb,CAAuBI,MAAvB,EAA+BrC,YAA/B,CAAP;EACH,CAFI,MAGA;IACD,MAAMO,UAAU,CAAC,0BAAD,CAAhB;EACH;AACJ,CAnBD;;AAoBA,IAAI+B,cAAc,GAAG,UAAU3B,YAAV,EAAwBI,aAAxB,EAAuCwB,SAAvC,EAAkDC,WAAlD,EAA+D;EAChF,IAAIC,WAAW,GAAG,EAAlB;EACA,IAAIxB,eAAe,GAAGD,kBAAkB,CAACD,aAAD,CAAxC;EACA,IAAI2B,cAAc,GAAGzB,eAAe,GAAGsB,SAAvC;;EACA,IAAIG,cAAc,IAAI,CAAtB,EAAyB;IACrB;IACA,IAAI1C,YAAY,KAAK,KAArB,EAA4B;MACxB,IAAIJ,KAAK,GAAG4C,WAAW,KAAM,CAAC,IAAIvB,eAAL,IAAwB,CAArD;IACH,CAFD,MAGK;MACD,IAAIrB,KAAK,GAAG4C,WAAZ;IACH;;IACDC,WAAW,CAACE,IAAZ,CAAiB/C,KAAjB;EACH,CATD,MAUK;IACD,KAAK,IAAIgD,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,SAApB,EAA+BK,CAAC,EAAhC,EAAoC;MAChC,IAAIC,WAAW,GAAG5B,eAAe,GAAG2B,CAApC;;MACA,IAAI3B,eAAe,IAAI,CAAvB,EAA0B;QACtB,IAAI,CAAC,UAAD,EAAa,WAAb,EAA0BC,OAA1B,CAAkCH,aAAlC,MAAqD,CAAC,CAA1D,EAA6D;UACzD;UACA0B,WAAW,CAACE,IAAZ,CAAiBvC,QAAQ,CAAC,CAAD,EAAIoC,WAAW,GAAGK,WAAlB,CAAzB,EAFyD,CAGzD;;UACAJ,WAAW,CAACE,IAAZ,CAAiBvC,QAAQ,CAAC,CAAD,EAAIoC,WAAW,GAAGK,WAAd,GAA4B,CAAhC,CAAzB,EAJyD,CAKzD;UACA;QACH,CAPD,MAQK;UACD,MAAMxC,SAAS,CAAC,sCAAD,CAAf;QACH;MACJ,CAZD,MAaK;QACDoC,WAAW,CAACE,IAAZ,CAAiBvC,QAAQ,CAACa,eAAD,EAAkBuB,WAAW,GAAGK,WAAhC,CAAzB;MACH;IACJ;EACJ;;EACD,IAAI9B,aAAa,KAAK,OAAtB,EAA+B;IAC3B0B,WAAW,CAACK,OAAZ,CAAoB,UAAUC,CAAV,EAAaH,CAAb,EAAgBI,CAAhB,EAAmB;MACnCA,CAAC,CAACJ,CAAD,CAAD,GAAOK,MAAM,CAACC,YAAP,CAAoBH,CAApB,CAAP;IACH,CAFD;EAGH;;EACD,OAAON,WAAP;AACH,CAzCD;;AA0CA,IAAIU,gBAAgB,GAAG,UAAUC,WAAV,EAAuBC,aAAvB,EAAsC;EACzD,IAAIC,UAAU,GAAG9B,IAAI,CAAC+B,GAAL,CAAS,CAAT,EAAY,IAAIF,aAAhB,CAAjB;EACA,OAAO7B,IAAI,CAACC,KAAL,CAAW2B,WAAW,GAAGE,UAAd,IAA4BA,UAAU,GAAG,CAAzC,CAAX,CAAP;AACH,CAHD;;AAIA,IAAIE,iBAAiB,GAAG,UAAUC,CAAV,EAAaC,CAAb,EAAgBC,CAAhB,EAAmBX,CAAnB,EAAsB;EAC1C,IAAI,OAAOA,CAAP,KAAa,WAAjB,EAA8B;IAC1BA,CAAC,GAAG,GAAJ;EACH;;EACD,OAAO,UAAUS,CAAV,GAAc,IAAd,GAAqBC,CAArB,GAAyB,IAAzB,GAAgCC,CAAhC,GAAoC,IAApC,GAA2CX,CAA3C,GAA+C,GAAtD;AACH,CALD;;AAMA,IAAIY,kBAAkB,GAAG,UAAUvC,UAAV,EAAsB;EAC3C,IAAIwC,aAAa,GAAGzD,QAAQ,CAAC,CAAD,EAAIiB,UAAJ,CAA5B;EACA,IAAIyC,UAAU,GAAG,EAAjB;;EACA,KAAK,IAAIlB,CAAC,GAAGvB,UAAU,GAAG,CAArB,EAAwB0C,UAAU,GAAG,CAA1C,EAA6CA,UAAU,GAAGF,aAA1D,EAAyEjB,CAAC,IAAI,EAAL,EAASmB,UAAU,EAA5F,EAAgG;IAC5F,IAAItD,QAAQ,GAAGL,QAAQ,CAAC,CAAD,EAAIwC,CAAJ,CAAvB;IACA,IAAI/B,SAAS,GAAGT,QAAQ,CAAC,CAAD,EAAIwC,CAAC,GAAG,CAAR,CAAxB;IACA,IAAIL,SAAS,GAAGnC,QAAQ,CAAC,CAAD,EAAIwC,CAAC,GAAG,CAAR,CAAxB;IACA,IAAIJ,WAAW,GAAGpC,QAAQ,CAAC,CAAD,EAAIwC,CAAC,GAAG,CAAR,CAA1B;IACA,IAAIjC,YAAY,GAAGH,eAAe,CAACC,QAAD,CAAlC;IACA,IAAIM,aAAa,GAAGH,gBAAgB,CAACC,SAAD,CAApC;IACA,IAAI4B,WAAW,GAAGH,cAAc,CAAC3B,YAAD,EAAeI,aAAf,EAA8BwB,SAA9B,EAAyCC,WAAzC,CAAhC;IACAsB,UAAU,CAACnD,YAAD,CAAV,GAA2B;MAAEqD,IAAI,EAAEjD,aAAR;MAAuBkD,MAAM,EAAExB;IAA/B,CAA3B;EACH;;EACDxC,eAAe,CAAC0C,IAAhB,CAAqBmB,UAArB;EACA,IAAII,iBAAiB,GAAG9D,QAAQ,CAAC,CAAD,EAAIwC,CAAJ,CAAhC;;EACA,IAAIsB,iBAAiB,KAAK,UAA1B,EAAsC;IAClC,OAAOjE,eAAP;EACH,CAFD,MAGK;IACD,OAAO2D,kBAAkB,CAACM,iBAAD,CAAzB;EACH;AACJ,CArBD;;AAsBAvE,OAAO,CAACE,SAAR,GAAoB,UAAUsE,eAAV,EAA2BC,OAA3B,EAAoC;EACpD,IAAIC,MAAM,GAAGD,OAAO,IAAIE,QAAQ,CAACC,aAAT,CAAuB,QAAvB,CAAxB;;EACA,IAAI,CAACJ,eAAL,EACI;EACJrE,YAAY,GAAG,IAAI0E,QAAJ,CAAaL,eAAb,CAAf,CAJoD,CAKpD;;EACAnE,YAAY,GAAGE,cAAc,CAACJ,YAAD,CAA7B;EACA,IAAI,CAACQ,QAAQ,CAACR,YAAD,EAAeE,YAAf,CAAb,EACI;EACJ,IAAIyE,kBAAkB,GAAGrE,QAAQ,CAAC,CAAD,EAAI,CAAJ,CAAjC;EACAH,eAAe,GAAG2D,kBAAkB,CAACa,kBAAD,CAApC;EACA,IAAIC,aAAa,GAAGzE,eAAe,CAAC,CAAD,CAAnC;EACA,IAAI0E,UAAU,GAAGD,aAAa,CAACE,UAAd,CAAyBX,MAAzB,CAAgC,CAAhC,CAAjB;EACA,IAAIY,WAAW,GAAGH,aAAa,CAACI,WAAd,CAA0Bb,MAA1B,CAAiC,CAAjC,CAAlB;EACAI,MAAM,CAACU,KAAP,GAAeJ,UAAf;EACAN,MAAM,CAACW,MAAP,GAAgBH,WAAhB;EACA,IAAII,MAAM,GAAG,EAAb;EACA,IAAIC,WAAW,GAAGR,aAAa,CAACS,WAAd,GACZT,aAAa,CAACS,WAAd,CAA0BlB,MAA1B,CAAiC,CAAjC,CADY,GAEZ,CAFN;EAGA,IAAImB,eAAe,GAAGV,aAAa,CAACW,eAAd,CAA8BpB,MAA9B,CAAqC,CAArC,CAAtB;EACA,IAAIqB,gBAAgB,GAAG,EAAvB;EACA,IAAIC,YAAY,GAAG,CAAnB;EACA,IAAIC,gBAAgB,GAAG,KAAvB;EACAd,aAAa,CAACe,aAAd,CAA4BxB,MAA5B,CAAmCnB,OAAnC,CAA2C,UAAUO,aAAV,EAAyBT,CAAzB,EAA4B8C,mBAA5B,EAAiD;IACxFJ,gBAAgB,CAAC1C,CAAD,CAAhB,GAAsB;MAClBS,aAAa,EAAEA,aADG;MAElBsC,iBAAiB,EAAE,KAFD;MAGlBC,cAAc,EAAE7F;IAHE,CAAtB;;IAKA,IAAIsD,aAAa,GAAG,CAAhB,KAAsB,CAA1B,EAA6B;MACzBiC,gBAAgB,CAAC1C,CAAD,CAAhB,CAAoB+C,iBAApB,GAAwC,IAAxC;MACAL,gBAAgB,CAAC1C,CAAD,CAAhB,CAAoBgD,cAApB,GAAqCvC,aAAa,GAAG,CAArD;IACH;;IACDkC,YAAY,IAAIlC,aAAhB;EACH,CAXD,EAWG7D,KAXH;;EAYA,IAAI+F,YAAY,GAAG,CAAf,KAAqB,CAAzB,EAA4B;IACxBC,gBAAgB,GAAG,IAAnB;IACA,IAAIK,aAAa,GAAGN,YAAY,GAAG,CAAnC;EACH;;EACD,IAAIO,iBAAiB,GAAGpB,aAAa,CAACqB,YAAd,CAA2B9B,MAAnD;EACA,IAAI+B,oBAAoB,GAAGF,iBAAiB,CAACG,MAA7C,CAzCoD,CA0CpD;;EACA,IAAIvB,aAAa,CAACwB,eAAlB,EAAmC;IAC/B,IAAIC,oBAAoB,GAAGzB,aAAa,CAACwB,eAAd,CAA8BjC,MAAzD;EACH,CAFD,MAGK;IACD;IACA,IAAI+B,oBAAoB,KAAK,CAA7B,EAAgC;MAC5B,IAAIG,oBAAoB,GAAG,CACvB3E,IAAI,CAAC4E,IAAL,CAAWzB,UAAU,GAAGE,WAAb,GAA2BU,YAA5B,GAA4C,CAAtD,CADuB,CAA3B;IAGH,CAJD,MAKK;MACD,MAAMc,KAAK,CAAC,6CAAD,CAAX;IACH;EACJ,CAxDmD,CAyDpD;;;EACA,KAAK,IAAIzD,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGoD,oBAApB,EAA0CpD,CAAC,EAA3C,EAA+C;IAC3C,IAAI0D,WAAW,GAAGR,iBAAiB,CAAClD,CAAD,CAAnC;IACAqC,MAAM,CAACrC,CAAD,CAAN,GAAY,EAAZ;IACA,IAAI2D,cAAc,GAAGJ,oBAAoB,CAACvD,CAAD,CAAzC,CAH2C,CAI3C;;IACA,KAAK,IAAIvB,UAAU,GAAG,CAAjB,EAAoBC,SAAS,GAAG,CAAhC,EAAmCkF,UAAU,GAAG,CAAhD,EAAmDC,SAAS,GAAG,IAA/D,EAAqEC,KAAK,GAAG,EAA7E,EAAiFtE,QAAQ,GAAG,CAA5F,EAA+FuE,MAAM,GAAG,CAAxG,EAA2GC,aAAa,GAAG,CAAhI,EAAmIvF,UAAU,GAAGkF,cAAhJ,EAAgKlF,UAAU,IAAImF,UAA9K,EAA0L;MACtL;MACA,QAAQtB,WAAR;QACI;QACA,KAAK,CAAL;UACI;UACA,KAAK,IAAI2B,CAAC,GAAG,CAAR,EAAWH,KAAK,GAAG,EAAxB,EAA4BG,CAAC,GAAGzB,eAAhC,EAAiDyB,CAAC,EAAlD,EAAsD;YAClD,IAAIvB,gBAAgB,CAACuB,CAAD,CAAhB,CAAoBlB,iBAAxB,EAA2C;cACvC;cACA,IAAImB,YAAY,GAAGxB,gBAAgB,CAACuB,CAAD,CAAhB,CAAoBjB,cAApB,GAAqCiB,CAAxD;cACAH,KAAK,CAAC/D,IAAN,CAAWvC,QAAQ,CAACkF,gBAAgB,CAACuB,CAAD,CAAhB,CAAoBjB,cAArB,EAAqCU,WAAW,GAAGjF,UAAd,GAA2ByF,YAAhE,CAAnB;YACH,CAJD,MAKK;cACD,IAAIC,UAAU,GAAG5F,OAAO,CAACmE,gBAAgB,CAACuB,CAAD,CAAhB,CAAoBxD,aAArB,EAAoCiD,WAAW,GAAGjF,UAAlD,EAA8DC,SAA9D,CAAxB;cACAoF,KAAK,CAAC/D,IAAN,CAAWoE,UAAU,CAAC5E,IAAtB;cACAd,UAAU,GAAG0F,UAAU,CAAC1F,UAAX,GAAwBiF,WAArC;cACAhF,SAAS,GAAGyF,UAAU,CAACzF,SAAvB;cACA,MAAMf,UAAU,CAAC,wCAAD,CAAhB;YACH;UACJ;;UACD0E,MAAM,CAACrC,CAAD,CAAN,CAAUD,IAAV,CAAe+D,KAAf;;UACA,IAAIlB,gBAAJ,EAAsB;YAClBgB,UAAU,GAAGX,aAAb;UACH,CAFD,MAGK;YACDW,UAAU,GAAG,CAAb;YACA,MAAMjG,UAAU,CAAC,uCAAD,CAAhB;UACH;;UACD;QACJ;;QACA,KAAK,CAAL;UACI;UACA;QACJ;;QACA,KAAK,CAAL;UACI;UACA;QACJ;;QACA,KAAK,CAAL;UACI;UACA;QACJ;;QACA,KAAK,CAAL;UACI;UACA;QACJ;;QACA,KAAK,CAAL;UACI;UACA;QACJ;;QACA,KAAK,CAAL;UACI;UACA;QACJ;;QACA,KAAK,KAAL;UACI;UACA,IAAIkG,SAAJ,EAAe;YACXA,SAAS,GAAG,KAAZ;YACA,IAAIO,WAAW,GAAG,CAAlB;YACA,IAAIC,UAAU,GAAG,CAAjB,CAHW,CAIX;;YACA,IAAIC,MAAM,GAAGpH,YAAY,CAACqH,OAAb,CAAqBb,WAAW,GAAGjF,UAAnC,EAA+CrB,YAA/C,CAAb;;YACA,IAAIkH,MAAM,IAAI,CAAV,IAAeA,MAAM,IAAI,GAA7B,EAAkC;cAC9B;cACAF,WAAW,GAAGE,MAAM,GAAG,CAAvB;YACH,CAHD,MAIK,IAAIA,MAAM,IAAI,CAAC,GAAX,IAAkBA,MAAM,IAAI,CAAC,CAAjC,EAAoC;cACrC;cACAD,UAAU,GAAG,CAACC,MAAD,GAAU,CAAvB;YACH;YAAC;YAHG,KAIA;cACD;cACAT,SAAS,GAAG,IAAZ;YACH;UACJ,CAlBD,MAmBK;YACD,IAAIW,WAAW,GAAGhH,QAAQ,CAAC,CAAD,EAAIkG,WAAW,GAAGjF,UAAlB,CAA1B,CADC,CAED;;YACA,KAAK,IAAIwF,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGI,UAApB,EAAgCJ,CAAC,EAAjC,EAAqC;cACjC,IAAIvB,gBAAgB,CAACqB,MAAD,CAAhB,CAAyBhB,iBAA7B,EAAgD;gBAC5C;gBACAiB,aAAa,GAAIA,aAAa,IAAK,IAAIxE,QAAvB,GAAoCgF,WAApD;gBACAhF,QAAQ,GAHoC,CAI5C;;gBACA,IAAIA,QAAQ,KAAKkD,gBAAgB,CAACqB,MAAD,CAAhB,CAAyBf,cAA1C,EAA0D;kBACtDc,KAAK,CAAC/D,IAAN,CAAWiE,aAAX;kBACAA,aAAa,GAAGxE,QAAQ,GAAG,CAA3B;kBACAuE,MAAM;gBACT;cACJ,CAVD,MAWK;gBACD,MAAMpG,UAAU,CAAC,wCAAD,CAAhB;cACH,CAdgC,CAejC;;;cACA,IAAIoG,MAAM,KAAKvB,eAAf,EAAgC;gBAC5BH,MAAM,CAACrC,CAAD,CAAN,CAAUD,IAAV,CAAe+D,KAAf;gBACAA,KAAK,GAAG,EAAR;gBACAC,MAAM,GAAG,CAAT;cACH;YACJ;;YACDK,WAAW,GAzBV,CA0BD;;YACA,IAAIA,WAAW,KAAK,CAApB,EAAuB;cACnBP,SAAS,GAAG,IAAZ;YACH;UACJ;;UACDD,UAAU,GAAG,CAAb;UACA;QACJ;;QACA;UACI;UACA;MA7GR;IA+GH;EACJ;;EACD,IAAInC,MAAM,CAACgD,UAAX,EAAuB;IACnB,IAAIC,GAAG,GAAGjD,MAAM,CAACgD,UAAP,CAAkB,IAAlB,CAAV,CADmB,CAEnB;;IACAC,GAAG,CAACC,SAAJ,GAAgB/D,iBAAiB,CAAC,GAAD,EAAM,GAAN,EAAW,GAAX,EAAgB,CAAhB,CAAjC,CAHmB,CAInB;;IACA,IAAIkB,aAAa,CAAC8C,YAAlB,EAAgC;MAC5B,IAAIC,YAAY,GAAG/C,aAAa,CAAC8C,YAAd,CAA2BvD,MAA3B,CAAkC,CAAlC,CAAnB;IACH,CAFD,MAGK;MACD,IAAIwD,YAAY,GAAG5C,WAAnB;IACH;;IACD,IAAI6C,SAAS,GAAGzC,MAAM,CAACgB,MAAvB;IACA,IAAI0B,0BAA0B,GAAG9C,WAAW,GAAG4C,YAA/C;IACA,IAAIG,eAAe,GAAGD,0BAA0B,KAAK,CAA/B,GAChBF,YADgB,GAEhBE,0BAFN;IAGA,IAAIE,cAAc,GAAGJ,YAArB;IACA,IAAIK,sBAAsB,GAAG,CAA7B;IACA,IAAIC,yBAAyB,GAAGrD,aAAa,CAACsD,yBAAd,CAAwC/D,MAAxC,CAA+C,CAA/C,CAAhC;IACA,IAAIgE,kBAAkB,GAAG,EAAzB;IACA,IAAIC,eAAe,GAAG,CAAtB;;IACA,IAAIxD,aAAa,CAACyD,YAAlB,EAAgC;MAC5BF,kBAAkB,GAAGvD,aAAa,CAACyD,YAAd,CAA2BlE,MAAhD;MACAiE,eAAe,GAAGD,kBAAkB,CAAChC,MAArC;IACH;;IACD,IAAIvB,aAAa,CAAC0D,QAAlB,EAA4B;MACxB,IAAIC,cAAc,GAAG3D,aAAa,CAAC0D,QAAd,CAAuBnE,MAA5C;MACA,IAAIqE,kBAAkB,GAAG9G,IAAI,CAAC+B,GAAL,CAAS,CAAT,EAAY+B,gBAAgB,CAAC,CAAD,CAAhB,CAAoBjC,aAAhC,CAAzB;IACH,CA5BkB,CA6BnB;;;IACA,KAAK,IAAIT,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG8E,SAApB,EAA+B9E,CAAC,EAAhC,EAAoC;MAChC;MACA,IAAIA,CAAC,GAAG,CAAJ,KAAU8E,SAAd,EAAyB;QACrBG,cAAc,GAAGD,eAAjB;MACH;;MACD,IAAIW,SAAS,GAAGtD,MAAM,CAACrC,CAAD,CAAN,CAAUqD,MAA1B;MACA,IAAIuC,QAAQ,GAAGV,sBAAsB,GAAGlF,CAAxC,CANgC,CAOhC;;MACA,KAAK,IAAI6F,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAG,CAApB,EAAuBD,CAAC,GAAGZ,cAAJ,EAAoBa,CAAC,GAAGH,SAA/C,EAA0DE,CAAC,EAA3D,EAA+D;QAC3D;QACA,KAAK,IAAIE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGhE,UAApB,EAAgCgE,CAAC,IAAID,CAAC,EAAtC,EAA0C;UACtC,IAAIE,YAAY,GAAG3D,MAAM,CAACrC,CAAD,CAAN,CAAU8F,CAAV,CAAnB;UACA,IAAIG,GAAG,GAAG,CAAV;UACA,IAAIC,KAAK,GAAG,CAAZ;UACA,IAAIC,IAAI,GAAG,CAAX;UACA,IAAIC,OAAO,GAAG,GAAd;;UACA,IAAId,eAAe,GAAG,CAAtB,EAAyB;YACrB,KAAK,IAAIe,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGf,eAApB,EAAqCe,CAAC,EAAtC,EAA0C;cACtC,IAAIhB,kBAAkB,CAACgB,CAAD,CAAlB,KAA0B,CAA1B,IAA+BhB,kBAAkB,CAACgB,CAAD,CAAlB,KAA0B,CAA7D,EAAgE;gBAC5D;gBACAD,OAAO,GAAGJ,YAAY,CAAC,IAAIK,CAAL,CAAZ,GAAsB,GAAhC;gBACA;cACH;YACJ;UACJ;;UACD,QAAQlB,yBAAR;YACI;YACA;YACA,KAAK,CAAL;cACI,IAAIzC,gBAAgB,CAAC,CAAD,CAAhB,CAAoBK,iBAAxB,EAA2C;gBACvC,IAAIuD,WAAW,GAAG1H,IAAI,CAAC+B,GAAL,CAAS,IAAT,EAAe+B,gBAAgB,CAAC,CAAD,CAAhB,CAAoBM,cAApB,GAAqC,CAApD,CAAlB;cACH,CAHL,CAII;;;cACAgD,YAAY,CAAC9F,OAAb,CAAqB,UAAU6D,MAAV,EAAkBwC,KAAlB,EAAyBC,OAAzB,EAAkC;gBACnDA,OAAO,CAACD,KAAD,CAAP,GAAiBD,WAAW,GAAGvC,MAA/B;cACH,CAFD;YAGJ;YACA;;YACA,KAAK,CAAL;cACIkC,GAAG,GAAGC,KAAK,GAAGC,IAAI,GAAG5F,gBAAgB,CAACyF,YAAY,CAAC,CAAD,CAAb,EAAkBtD,gBAAgB,CAAC,CAAD,CAAhB,CAAoBjC,aAAtC,CAArC;cACA;YACJ;;YACA,KAAK,CAAL;cACIwF,GAAG,GAAG1F,gBAAgB,CAACyF,YAAY,CAAC,CAAD,CAAb,EAAkBtD,gBAAgB,CAAC,CAAD,CAAhB,CAAoBjC,aAAtC,CAAtB;cACAyF,KAAK,GAAG3F,gBAAgB,CAACyF,YAAY,CAAC,CAAD,CAAb,EAAkBtD,gBAAgB,CAAC,CAAD,CAAhB,CAAoBjC,aAAtC,CAAxB;cACA0F,IAAI,GAAG5F,gBAAgB,CAACyF,YAAY,CAAC,CAAD,CAAb,EAAkBtD,gBAAgB,CAAC,CAAD,CAAhB,CAAoBjC,aAAtC,CAAvB;cACA;YACJ;;YACA,KAAK,CAAL;cACI,IAAIgF,cAAc,KAAKtI,SAAvB,EAAkC;gBAC9B,MAAMsG,KAAK,CAAC,iCAAD,CAAX;cACH;;cACD,IAAIgD,aAAa,GAAGT,YAAY,CAAC,CAAD,CAAhC;cACAC,GAAG,GAAG1F,gBAAgB,CAACkF,cAAc,CAACgB,aAAD,CAAf,EAAgC,EAAhC,CAAtB;cACAP,KAAK,GAAG3F,gBAAgB,CAACkF,cAAc,CAACC,kBAAkB,GAAGe,aAAtB,CAAf,EAAqD,EAArD,CAAxB;cACAN,IAAI,GAAG5F,gBAAgB,CAACkF,cAAc,CAAC,IAAIC,kBAAJ,GAAyBe,aAA1B,CAAf,EAAyD,EAAzD,CAAvB;cACA;YACJ;;YACA,KAAK,CAAL;cACI,MAAM9I,UAAU,CAAC,wCAAD,CAAhB;cACA;YACJ;;YACA,KAAK,CAAL;cACI,MAAMA,UAAU,CAAC,2BAAD,CAAhB;cACA;YACJ;;YACA,KAAK,CAAL;cACI,MAAMA,UAAU,CAAC,4BAAD,CAAhB;cACA;YACJ;;YACA,KAAK,CAAL;cACI,MAAMA,UAAU,CAAC,6BAAD,CAAhB;cACA;YACJ;;YACA;cACI,MAAMA,UAAU,CAAC,qCAAD,EAAwCwH,yBAAxC,CAAhB;cACA;UAnDR;;UAqDAT,GAAG,CAACC,SAAJ,GAAgB/D,iBAAiB,CAACqF,GAAD,EAAMC,KAAN,EAAaC,IAAb,EAAmBC,OAAnB,CAAjC;UACA1B,GAAG,CAACgC,QAAJ,CAAaX,CAAb,EAAgBH,QAAQ,GAAGC,CAA3B,EAA8B,CAA9B,EAAiC,CAAjC;QACH;MACJ;;MACDX,sBAAsB,GAAGD,cAAzB;IACH;EACJ;;EACD,OAAOxD,MAAP;AACH,CAtSD"},"metadata":{},"sourceType":"script"}